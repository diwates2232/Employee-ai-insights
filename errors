// server.js
const express = require('express');
const cors    = require('cors');
const path    = require('path');

const employeeRoutes  = require('./routes/employeeRoutes');
const liveOccupancyRt = require('./routes/liveOccupancyRoutes');

const app = express();
app.use(cors());
app.use(express.json());

// TEMP: simple sanity-check endpoint
app.get('/ping', (req, res) => res.send('pong'));

// mount your routers (they themselves define '/employees' and '/live-occupancy')
app.use('/api', employeeRoutes);
app.use('/api', liveOccupancyRt);

// ‚Äî‚Äî‚Äî‚Äî‚Äî DEBUG: list all directly registered routes ‚Äî‚Äî‚Äî‚Äî‚Äî
if (app._router && Array.isArray(app._router.stack)) {
  console.log('\nüìã Registered endpoints:');
  app._router.stack.forEach(layer => {
    if (layer.route && layer.route.path) {
      const methods = Object
        .keys(layer.route.methods)
        .map(m => m.toUpperCase())
        .join(',');
      console.log(`  ${methods}\t${layer.route.path}`);
    }
  });
} else {
  console.warn('‚ö†Ô∏è No routes found in app._router.stack');
}

// serve your React build (if you have one)
const buildPath = path.join(__dirname, '..', 'client', 'build');
app.use(express.static(buildPath));

// health-check
app.get('/health', (req, res) => res.send('OK'));

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running at http://localhost:${PORT}`));











read all files deatsils and Solve the errors if need to make any changes in file then update only this file and give me update file carefully.
Dont make changes on another file .


File 1

// config/db.js

const sql = require('mssql');
const dotenv = require('dotenv');
dotenv.config();

const config = {
  server: process.env.DB_SERVER,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
  options: {
    encrypt: true,
    trustServerCertificate: true,
  },
};

const pool = new sql.ConnectionPool(config);
const poolConnect = pool.connect()
  .then(() => console.log('‚úÖ MSSQL pool connected'))
  .catch(err => console.error('‚ùå MSSQL pool connection failed:', err));

pool.on('error', err => {
  console.error('‚ùå MSSQL pool error:', err);
});

module.exports = { sql, poolConnect, pool };



File 2

// controllers/employeeController.js

const { poolConnect, pool } = require('../config/db');

exports.getEmployeeData = async (req, res) => {
  try {
    await poolConnect;
    const request = pool.request();

    // Pagination params (defaults: page 1, 100 rows)
    const page     = parseInt(req.query.page)     || 1;
    const pageSize = parseInt(req.query.pageSize) || 100;
    const offset   = (page - 1) * pageSize;

    const sqlQuery = ` 
      WITH CombinedQuery AS(
		SELECT 
	    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    t1.ObjectName1,
	t1.PartitionName2 As location,
	t5_card.CardNumber,
t5_admit.value AS AdmitCode,
t5_dir.value AS Direction,
    t1.ObjectName2,
	t5_rej.value AS Rejection_Type,
	CASE 
        WHEN t3.Name IN ('Contractor', 'Terminated Contractor') THEN t2.Text12
        ELSE CAST(t2.Int1 AS NVARCHAR)
    END AS "EmployeeID",
    t3.Name AS PersonnelType,
    t1.MessageType,t1.XmlGUID
	FROM
    [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] AS t1
LEFT JOIN
    [ACVSCore].[Access].[Personnel] AS t2
    ON t1.ObjectIdentity1 = t2.GUID
LEFT JOIN
    [ACVSCore].[Access].[PersonnelType] AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID]
LEFT JOIN
    [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID
    AND t5_admit.Name = 'AdmitCode'
LEFT JOIN
    [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxmlShred] AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection', 'OutDirection')
    LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] AS t_xml
        ON t1.XmlGUID = t_xml.GUID
    -- Pre-pull shredded ‚ÄúCard‚Äù row
    LEFT JOIN (
    SELECT GUID, [value]
    FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
    WHERE [Name] IN ('Card', 'CHUID')
    ) AS SCard
    ON t1.XmlGUID = SCard.GUID
    /* NEW: three-stage CardNumber resolution */
    OUTER APPLY (
    SELECT COALESCE(
        -- 1) <LogMessage><CHUID><Card>‚Ä¶</Card></CHUID>
        TRY_CAST(t_xml.XmlMessage AS XML)
        .value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
        -- 2) <LogMessage><CHUID>‚Ä¶</CHUID> (no nested <Card>)
        TRY_CAST(t_xml.XmlMessage AS XML)
        .value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
        -- 3) shredded fallback
        SCard.[value]
    ) AS CardNumber
    ) AS t5_card
 
LEFT JOIN
    [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] AS t5_Rej
    ON t1.XmlGUID = t5_Rej.GUID
    AND t5_Rej.Name = 'RejectCode'
 
   
   --include both admits and rejects
   WHERE t1.MessageType IN ('CardAdmitted', 'CardRejected')
   AND t1.PartitionName2 = 'APAC.Default'
   AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) >= '2025-01-01')
 
 SELECT
        -- Format as ISO string for the full datetime
        CONVERT(VARCHAR(25), LocaleMessageTime, 126) AS LocaleMessageTime,
        -- Keep date only as 'YYYY-MM-DD'
        CONVERT(VARCHAR(10), LocaleMessageTime, 23)  AS Dateonly,
        -- Extract just the time as 'HH:MM:SS'
        CONVERT(VARCHAR(8), LocaleMessageTime, 108)  AS Swipe_Time,
        EmployeeID,
        ObjectName1,
        PersonnelType,
        CardNumber,
        AdmitCode,
        Direction,
        ObjectName2 AS Door,
        Rejection_Type
      FROM CombinedQuery
      ORDER BY LocaleMessageTime DESC
      OFFSET ${offset} ROWS
      FETCH NEXT ${pageSize} ROWS ONLY;
    `;

    const result = await request.query(sqlQuery);

    res.json({
      page,
      pageSize,
      data: result.recordset,
    });
  } catch (error) {
    console.error('SQL error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};




file 3

// controllers/liveOccupancyController.js

const { poolConnect, pool, sql } = require('../config/db');
const mapDoorToZone = require('../data/doorZoneMap');

async function fetchNewEvents(since) {
  const req = pool.request();
  req.input('since', sql.DateTime2, since);
  const result = await req.query(`
    WITH CombinedQuery AS (
      SELECT 
        DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE 
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          SCard.[value]
        ) AS CardNumber,
        t5_admit.value AS AdmitCode,
        t5_dir.value   AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]      t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType]  t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_admit
        ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_dir
        ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, [value]
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE [Name] IN ('Card','CHUID')
      ) AS SCard
        ON t1.XmlGUID = SCard.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return result.recordset;
}

async function buildOccupancy(allEvents) {
  const current = {};
  for (const evt of allEvents) {
    const {
      EmployeeID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      Dateonly,
      Swipe_Time,
      Direction,
      Door
    } = evt;

    let zone = mapDoorToZone(Door, Direction) || 'Unknown Zone';

    if (Direction === 'InDirection') {
      current[EmployeeID] = {
        Dateonly,
        Swipe_Time,
        EmployeeID,
        ObjectName1,
        CardNumber,
        PersonnelType,
        zone
      };
    } else {
      delete current[EmployeeID];
    }
  }

  const zoneMap = {};
  for (const emp of Object.values(current)) {
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }

  const summary = Object.entries(zoneMap).map(([zone, emps]) => ({
    zone,
    count: emps.length
  }));

  return { asOf: new Date().toISOString(), summary, details: zoneMap };
}

exports.getLiveOccupancy = async (req, res) => {
  try {
    await poolConnect;

    res.writeHead(200, {
      'Content-Type':      'text/event-stream',
      'Cache-Control':     'no-cache',
      'Connection':        'keep-alive'
    });
    res.write('\n');

    let lastSeen = new Date(Date.now() - 1000 * 60 * 60); // start one hour back (or adjust)

    // keep a running list of all in-scope events to compute occupancy
    const allEvents = [];

    const checkForNew = async () => {
      const newEvents = await fetchNewEvents(lastSeen);
      if (newEvents.length > 0) {
        // update our lastSeen to the timestamp of the newest event
        lastSeen = newEvents[newEvents.length - 1].LocaleMessageTime;
        // add them to the master list
        allEvents.push(...newEvents);
        // rebuild occupancy and push
        const payload = await buildOccupancy(allEvents);
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
      }
    };

    // initial emit (empty or existing in last hour)
    {
      const recent = await fetchNewEvents(new Date(Date.now() - 1000*60*60));
      if (recent.length) {
        lastSeen = recent[recent.length-1].LocaleMessageTime;
        allEvents.push(...recent);
      }
      const initial = await buildOccupancy(allEvents);
      res.write(`data: ${JSON.stringify(initial)}\n\n`);
    }

    const interval = setInterval(checkForNew, 1000);

    req.on('close', () => clearInterval(interval));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};



file 4

// routes/liveOccupancyRoutes.js

const express = require('express');
const router  = express.Router();
const { getLiveOccupancy } = require('../controllers/liveOccupancyController');

router.get('/live-occupancy',getLiveOccupancy);

module.exports = router;




file 5

const express = require('express');
const router = express.Router();
const { getEmployeeData } = require('../controllers/employeeController');

router.get('/employees', getEmployeeData);

module.exports = router;


file 6


// const express = require('express');
// const cors = require('cors');
// const employeeRoutes = require('./routes/employeeRoutes');
// const doorZoneMap=require('./data/doorZoneMap');
// const liveRt  = require('./routes/liveOccupancyRoutes');
// const app = express();

// app.use(cors());
// app.use(express.json());

// app.use('/api', employeeRoutes);
// app.use('/api', liveRt);  // now GET /api/live-occupancynode 

// const PORT = 5000;
// app.listen(PORT, () => {
//   console.log(`Server running at http://localhost:${PORT}`);
// });





const express         = require('express');
const cors            = require('cors');
const path            = require('path');

const employeeRoutes    = require('./routes/employeeRoutes');
const liveOccupancyRt   = require('./routes/liveOccupancyRoutes');

const app = express();
app.use(cors());
app.use(express.json());

// TEMP: make sure Express is picking up routes at all
app.get('/ping', (req, res) => res.send('pong'));

// mount each router on its own prefix
app.use('/api/employees', employeeRoutes);
app.use('/api/occupancy',  liveOccupancyRt);

// helper: safely walk the router stack if it exists
function listAllEndpoints(app) {
  const results = [];
  const stack = app._router && app._router.stack;
  if (!stack) return results;

  function recurse(layers, parentPath = '') {
    layers.forEach(layer => {
      // direct route
      if (layer.route && layer.route.path) {
        const methods = Object
          .keys(layer.route.methods)
          .map(m => m.toUpperCase());
        results.push({ path: parentPath + layer.route.path, methods });
      }
      // mounted router
      else if (layer.name === 'router' && layer.handle.stack) {
        // extract the mount path from the internal regexp
        const mountPath = layer.regexp.source
          .replace('^\\', '')
          .replace('\\/?(?=\\/|$)', '')
          .replace(/\\\//g, '/');
        recurse(layer.handle.stack, parentPath + mountPath);
      }
    });
  }

  recurse(stack);
  return results;
}

// ‚Äî‚Äî‚Äî‚Äî‚Äî DEBUG: list all registered endpoints ‚Äî‚Äî‚Äî‚Äî‚Äî
const endpoints = listAllEndpoints(app);
if (endpoints.length) {
  console.log('\nüìã Registered endpoints:');
  endpoints.forEach(e =>
    console.log(`  ${e.methods.join(',')}\t${e.path}`)
  );
} else {
  console.warn('‚ö†Ô∏è No endpoints found on app._router.stack');
}

// serve React build
const buildPath = path.join(__dirname, '..', 'client', 'build');
app.use(express.static(buildPath));

// health check
app.get('/health', (req, res) => res.send('OK'));

const PORT = process.env.PORT || 5000;
app.listen(PORT, () =>
  console.log(`Server running at http://localhost:${PORT}`)
);
