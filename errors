// controllers/liveOccupancyController.js

const { poolConnect, pool, sql } = require('../config/db');
const doorZoneMap    = require('../data/doorZoneMap');
const zoneFloorMap   = require('../data/zoneFloorMap');

// helper: map door + direction to zone, with fallback for APAC_IN_PUN
function mapDoorToZone(doorName, direction) {
  const key = `${doorName}___${direction}`;
  if (doorZoneMap[key]) {
    return doorZoneMap[key];
  }
  // any other APAC_IN_PUN door counts as inside office but unknown zone
  if (doorName.startsWith('APAC_IN_PUN')) {
    return 'Unknown Zone';
  }
  return 'Unknown Zone';
}

async function fetchNewEvents(since) {
  await poolConnect;
  const req = pool.request();
  req.input('since', sql.DateTime2, since);
  const result = await req.query(`
    WITH CombinedQuery AS (
      SELECT 
        DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
        t1.ObjectName1,
        -- permanent employees by Int1; contractors by Text12
        CASE 
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        -- fallback: Card or CHUID element
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          SCard.[value]
        ) AS CardNumber,
        t5_admit.value AS AdmitCode,
        t5_dir.value   AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_admit
        ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_dir
        ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, [value]
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE [Name] IN ('Card','CHUID')
      ) AS SCard
        ON t1.XmlGUID = SCard.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);
  return result.recordset;
}

async function fetchTotalVisitedToday() {
  await poolConnect;
  const req = pool.request();
  const todayStart = new Date();
  todayStart.setHours(0, 0, 0, 0);
  req.input('start', sql.DateTime2, todayStart);

  const result = await req.query(`
    WITH DailyVisits AS (
      SELECT DISTINCT
        CASE 
          WHEN pt.Name IN ('Contractor','Terminated Contractor') THEN p.Text12
          WHEN pt.Name IN ('Temp Badge','Visitor','Property Management') THEN p.Text9
          ELSE CAST(p.Int1 AS NVARCHAR)
        END AS EmployeeID,
        log.ObjectIdentity1 AS PersonGUID
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] log
      LEFT JOIN [ACVSCore].[Access].[Personnel]     p  ON log.ObjectIdentity1 = p.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] pt ON p.PersonnelTypeId = pt.ObjectID
      WHERE
        log.MessageType = 'CardAdmitted'
        AND log.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * log.MessageLocaleOffset, log.MessageUTC) >= @start
    )
    SELECT COUNT(*) AS totalVisitedToday
    FROM DailyVisits;
  `);

  return result.recordset[0]?.totalVisitedToday || 0;
}

async function fetchVisitedTodayBreakdown() {
  await poolConnect;
  const req = pool.request();
  const todayStart = new Date();
  todayStart.setHours(0, 0, 0, 0);
  req.input('start', sql.DateTime2, todayStart);

  const result = await req.query(`
    WITH CombinedEmployeeData AS (
      SELECT
        CASE
          WHEN pt.Name IN ('Contractor','Terminated Contractor') THEN p.Text12
          WHEN pt.Name IN ('Temp Badge','Visitor','Property Management') THEN p.Text9
          ELSE CAST(p.Int1 AS NVARCHAR)
        END AS EmployeeID,
        pt.Name AS PersonnelType,
        log.ObjectIdentity1 AS PersonGUID,
        DATEADD(MINUTE, -1 * log.MessageLocaleOffset, log.MessageUTC) AS LocaleMessageTime
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] log
      INNER JOIN [ACVSCore].[Access].[Personnel]     p  ON log.ObjectIdentity1 = p.GUID
      INNER JOIN [ACVSCore].[Access].[PersonnelType] pt ON p.PersonnelTypeID = pt.ObjectID
      WHERE
        log.MessageType = 'CardAdmitted'
        AND log.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * log.MessageLocaleOffset, log.MessageUTC) >= @start
    ),
    RankedEmployeeData AS (
      SELECT *,
        ROW_NUMBER() OVER (
          PARTITION BY PersonGUID
          ORDER BY LocaleMessageTime DESC
        ) AS rn
      FROM CombinedEmployeeData
      WHERE PersonGUID IS NOT NULL
    )
    SELECT
      CASE
        WHEN PersonnelType IN (
          'Contractor','Terminated Contractor',
          'None','Property Management',
          'Temp Badge','Visitor'
        ) THEN 'Contractor'
        ELSE 'Employee'
      END AS bucket,
      COUNT(*) AS cnt
    FROM RankedEmployeeData
    WHERE rn = 1
    GROUP BY
      CASE
        WHEN PersonnelType IN (
          'Contractor','Terminated Contractor',
          'None','Property Management',
          'Temp Badge','Visitor'
        ) THEN 'Contractor'
        ELSE 'Employee'
      END;
  `);

  const breakdown = { employees: 0, contractors: 0 };
  for (const { bucket, cnt } of result.recordset) {
    if (bucket === 'Employee')   breakdown.employees = cnt;
    if (bucket === 'Contractor') breakdown.contractors = cnt;
  }
  breakdown.total = breakdown.employees + breakdown.contractors;
  return breakdown;
}

async function buildOccupancy(allEvents) {
  const current      = {};
  const uniquePeople = new Map();

  for (const evt of allEvents) {
    const {
      EmployeeID, ObjectName1, PersonnelType,
      CardNumber, Dateonly, Swipe_Time,
      Direction, Door
    } = evt;

    // unique key: prefer stable EmployeeID, else CardNumber, else name
    const dedupKey = EmployeeID || CardNumber || ObjectName1;
    const zone     = mapDoorToZone(Door, Direction);

    // only an OutDirection at the real “Out of office” door removes presence
    if (Direction === 'OutDirection' && zone === 'Out of office') {
      delete current[dedupKey];
      uniquePeople.delete(dedupKey);
      continue;
    }

    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, { PersonnelType });
      current[dedupKey] = {
        Dateonly, Swipe_Time, EmployeeID, ObjectName1,
        CardNumber, PersonnelType, zone
      };
    } else {
      // any other swipe-out clears current presence
      delete current[dedupKey];
      uniquePeople.delete(dedupKey);
    }
  }

  // live personnel counts
  let employeeCount   = 0;
  let contractorCount = 0;
  for (const { PersonnelType } of uniquePeople.values()) {
    if (['Employee','Terminated Personnel'].includes(PersonnelType)) {
      employeeCount++;
    } else {
      contractorCount++;
    }
  }

  // zone aggregation
  const zoneMap = {};
  for (const emp of Object.values(current)) {
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }
  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const byType = emps.reduce((acc, { PersonnelType }) => {
        acc[PersonnelType] = (acc[PersonnelType] || 0) + 1;
        return acc;
      }, {});
      return [zone, { total: emps.length, byPersonnelType: byType, employees: emps }];
    })
  );

  // floor aggregation
  const floorMap = {};
  for (const [zone, d] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += d.total;
    for (const [pt, c] of Object.entries(d.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] =
        (floorMap[floor].byPersonnelType[pt] || 0) + c;
    }
  }

  // prepare arrays for front end
  const summary        = Object.entries(zoneDetails).map(([z,d]) => ({ zone: z, count: d.total }));
  const zoneBreakdown  = Object.entries(zoneDetails).map(([z,d]) => ({ zone: z, ...d.byPersonnelType, total: d.total }));
  const floorBreakdown = Object.entries(floorMap).map(([f,d]) => ({ floor: f, ...d.byPersonnelType, total: d.total }));

  const personnelBreakdown = [];
  if (employeeCount)   personnelBreakdown.push({ personnelType: 'Employee', count: employeeCount });
  if (contractorCount) personnelBreakdown.push({ personnelType: 'Contractor', count: contractorCount });

  return {
    asOf:             new Date().toISOString(),
    summary,
    zoneBreakdown,
    floorBreakdown,
    details:          zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
    personnelBreakdown
  };
}

exports.getLiveOccupancy = async (req, res) => {
  try {
    await poolConnect;
    res.writeHead(200, {
      'Content-Type':  'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection':    'keep-alive'
    });
    res.write('\n');

    let lastSeen = new Date(Date.now() - 1000 * 60 * 60 * 24);
    const events = [];

    const push = async () => {
      const fresh = await fetchNewEvents(lastSeen);
      if (fresh.length) {
        lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
        events.push(...fresh);

        const payload = await buildOccupancy(events);
        payload.totalVisitedToday = await fetchTotalVisitedToday();
        payload.visitedToday      = await fetchVisitedTodayBreakdown();
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
      }
    };

    // initial emit
    {
      const recent = await fetchNewEvents(lastSeen);
      if (recent.length) {
        lastSeen = recent[recent.length - 1].LocaleMessageTime;
        events.push(...recent);
      }
      const initial = await buildOccupancy(events);
      initial.totalVisitedToday = await fetchTotalVisitedToday();
      initial.visitedToday      = await fetchVisitedTodayBreakdown();
      res.write(`data: ${JSON.stringify(initial)}\n\n`);
    }

    const timer = setInterval(push, 1000);
    req.on('close', () => clearInterval(timer));
  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) res.status(500).json({ error: 'Internal Server Error' });
  }
};






















Read above file carefully and solve above error

// controllers/liveOccupancyController.js

const { poolConnect, pool, sql } = require('../config/db');
const doorZoneMap    = require('../data/doorZoneMap');
const zoneFloorMap   = require('../data/zoneFloorMap');

// helper: map door + direction to zone, with fallback for APAC_IN_PUN
function mapDoorToZone(doorName, direction) {
  const key = `${doorName}___${direction}`;
  if (doorZoneMap[key]) {
    return doorZoneMap[key];
  }
  // any other APAC_IN_PUN door counts as inside office but unknown zone
  if (doorName.startsWith('APAC_IN_PUN')) {
    return 'Unknown Zone';
  }
  return 'Unknown Zone';
}

async function fetchNewEvents(since) {
  await poolConnect;
  const req = pool.request();
  req.input('since', sql.DateTime2, since);
  const result = await req.query(`
    WITH CombinedQuery AS (
      SELECT 
        DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
        t1.ObjectName1,
        -- permanent employees by Int1; contractors by Text12
        CASE 
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
		t1.ObjectIdentity1,
        t3.Name AS PersonnelType,
        -- fallback: Card or CHUID element
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          SCard.[value]
        ) AS CardNumber,
        t5_admit.value AS AdmitCode,
        t5_dir.value   AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]      t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType]  t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_admit
        ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_dir
        ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, [value]
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE [Name] IN ('Card','CHUID')
      ) AS SCard
        ON t1.XmlGUID = SCard.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > '5-20-2025' 
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
	  ObjectIdentity1,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);
  return result.recordset;
}

async function fetchTotalVisitedToday() {
  await poolConnect;
  const req = pool.request();
  const todayStart = new Date();
  todayStart.setHours(0, 0, 0, 0);
  req.input('start', sql.DateTime2, todayStart);

  const result = await req.query(`
    WITH DailyVisits AS (
      SELECT DISTINCT
        CASE 
          WHEN pt.Name IN ('Contractor','Terminated Contractor') THEN p.Text12
          WHEN pt.Name IN ('Temp Badge','Visitor','Property Management') THEN p.Text9
          ELSE CAST(p.Int1 AS NVARCHAR)
        END AS EmployeeID,
		ObjectIdentity1
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] log
      LEFT JOIN [ACVSCore].[Access].[Personnel] p 
        ON log.ObjectIdentity1 = p.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] pt 
        ON p.PersonnelTypeId = pt.ObjectID
      WHERE
        log.MessageType = 'CardAdmitted'
        AND log.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * log.MessageLocaleOffset, log.MessageUTC) >= '5-20-2025' 
    )
    SELECT COUNT(*) AS totalVisitedToday FROM DailyVisits;
  `);

  return result.recordset[0]?.totalVisitedToday || 0;
}

async function fetchVisitedTodayBreakdown() {
  await poolConnect;
  const req = pool.request();
  const todayStart = new Date();
  todayStart.setHours(0, 0, 0, 0);
  req.input('start', sql.DateTime2, todayStart);

  const result = await req.query(`
    WITH CombinedEmployeeData AS (
      SELECT
        CASE
          WHEN pt.Name IN ('Contractor','Terminated Contractor') THEN p.Text12
          WHEN pt.Name IN ('Temp Badge','Visitor','Property Management') THEN p.Text9
          ELSE CAST(p.Int1 AS NVARCHAR)
        END AS EmployeeID,
        pt.Name AS PersonnelType,
        DATEADD(MINUTE, -1 * log.MessageLocaleOffset, log.MessageUTC) AS LocaleMessageTime
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] log
      INNER JOIN [ACVSCore].[Access].[Personnel] p 
        ON log.ObjectIdentity1 = p.GUID
      INNER JOIN [ACVSCore].[Access].[PersonnelType] pt 
        ON p.PersonnelTypeID = pt.ObjectID
      WHERE
        log.MessageType = 'CardAdmitted'
        AND log.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * log.MessageLocaleOffset, log.MessageUTC) >= @start
    ),
    RankedEmployeeData AS (
      SELECT *,
        ROW_NUMBER() OVER (
          PARTITION BY ObjectIdentity1
          ORDER BY LocaleMessageTime DESC
        ) AS rn
      FROM CombinedEmployeeData
      WHERE ObjectIdentity1 IS NOT NULL
    )
    SELECT
      CASE
        WHEN PersonnelType IN (
          'Contractor','Terminated Contractor',
          'None','Property Management',
          'Temp Badge','Visitor'
        ) THEN 'Contractor'
        ELSE 'Employee'
      END AS bucket,
      COUNT(*) AS cnt
    FROM RankedEmployeeData
    WHERE rn = 1
    GROUP BY
      CASE
        WHEN PersonnelType IN (
          'Contractor','Terminated Contractor',
          'None','Property Management',
          'Temp Badge','Visitor'
        ) THEN 'Contractor'
        ELSE 'Employee'
      END;
  `);

  const breakdown = { employees: 0, contractors: 0 };
  for (const { bucket, cnt } of result.recordset) {
    if (bucket === 'Employee')   breakdown.employees = cnt;
    if (bucket === 'Contractor') breakdown.contractors = cnt;
  }
  breakdown.total = breakdown.employees + breakdown.contractors;
  return breakdown;
}

async function buildOccupancy(allEvents) {
  const current      = {};
  const uniquePeople = new Map();

  for (const evt of allEvents) {
    const {
      EmployeeID, ObjectName1, PersonnelType,
      CardNumber, Dateonly, Swipe_Time,
      Direction, Door
    } = evt;

    // unique key: prefer stable EmployeeID, else fall back to CardNumber or name
    const dedupKey = EmployeeID || CardNumber || ObjectName1;
    const zone     = mapDoorToZone(Door, Direction);

    // only an OutDirection at the real “Out of office” door removes presence
    if (Direction === 'OutDirection' && zone === 'Out of office') {
      delete current[dedupKey];
      uniquePeople.delete(dedupKey);
      continue;
    }

    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, { PersonnelType });
      current[dedupKey] = {
        Dateonly, Swipe_Time, EmployeeID, ObjectName1,
        CardNumber, PersonnelType, zone
      };
    } else {
      // any other swipe-out clears current presence
      delete current[dedupKey];
      uniquePeople.delete(dedupKey);
    }
  }

  // live personnel counts
  let employeeCount   = 0;
  let contractorCount = 0;
  for (const { PersonnelType } of uniquePeople.values()) {
    if (['Employee','Terminated Personnel'].includes(PersonnelType)) {
      employeeCount++;
    } else {
      contractorCount++;
    }
  }

  // zone aggregation
  const zoneMap = {};
  for (const emp of Object.values(current)) {
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }

  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const byType = emps.reduce((acc, { PersonnelType }) => {
        acc[PersonnelType] = (acc[PersonnelType] || 0) + 1;
        return acc;
      }, {});
      return [zone, { total: emps.length, byPersonnelType: byType, employees: emps }];
    })
  );

  // floor aggregation
  const floorMap = {};
  for (const [zone, d] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += d.total;
    for (const [pt, c] of Object.entries(d.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt] || 0) + c;
    }
  }

  // prepare arrays for frontend
  const summary        = Object.entries(zoneDetails).map(([z,d]) => ({ zone: z, count: d.total }));
  const zoneBreakdown  = Object.entries(zoneDetails).map(([z,d]) => ({ zone: z, ...d.byPersonnelType, total: d.total }));
  const floorBreakdown = Object.entries(floorMap).map(([f,d]) => ({ floor: f, ...d.byPersonnelType, total: d.total }));

  const personnelBreakdown = [];
  if (employeeCount)   personnelBreakdown.push({ personnelType: 'Employee',   count: employeeCount });
  if (contractorCount) personnelBreakdown.push({ personnelType: 'Contractor', count: contractorCount });

  return {
    asOf:             new Date().toISOString(),
    summary,
    zoneBreakdown,
    floorBreakdown,
    details:          zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
    personnelBreakdown
  };
}

exports.getLiveOccupancy = async (req, res) => {
  try {
    await poolConnect;
    res.writeHead(200, {
      'Content-Type':  'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection':    'keep-alive'
    });
    res.write('\n');

    let lastSeen = new Date(Date.now() - 1000 * 60 * 60 * 24);
    const events = [];

    const push = async () => {
      const fresh = await fetchNewEvents(lastSeen);
      if (fresh.length) {
        lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
        events.push(...fresh);
        const payload = await buildOccupancy(events);
        payload.totalVisitedToday = await fetchTotalVisitedToday();
        payload.visitedToday      = await fetchVisitedTodayBreakdown();
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
      }
    };

    // initial emit
    {
      const recent = await fetchNewEvents(lastSeen);
      if (recent.length) {
        lastSeen = recent[recent.length - 1].LocaleMessageTime;
        events.push(...recent);
      }
      const initial = await buildOccupancy(events);
      initial.totalVisitedToday = await fetchTotalVisitedToday();
      initial.visitedToday      = await fetchVisitedTodayBreakdown();
      res.write(`data: ${JSON.stringify(initial)}\n\n`);
    }

    const timer = setInterval(push, 1000);
    req.on('close', () => clearInterval(timer));
  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) res.status(500).json({ error: 'Internal Server Error' });
  }
};

