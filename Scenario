# src/labelers.py

import pandas as pd
from datetime import timedelta

def label_anomaly(df: pd.DataFrame, window_minutes: int = 10, max_swipes: int = 5) -> pd.DataFrame:
    """
    Label 'anomaly' if an employee has more than `max_swipes` within `window_minutes`.
    This version sets LocaleMessageTime as the index so that .rolling("10min") works correctly.
    """
    # Ensure proper datetime and sort
    df = df.copy()
    df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")
    df = df.dropna(subset=["LocaleMessageTime"])
    df = df.sort_values(["EmployeeID", "LocaleMessageTime"])

    # Temporarily set the index to LocaleMessageTime (DatetimeIndex)
    df = df.set_index("LocaleMessageTime")

    # Compute rolling count of swipes per EmployeeID over x-minute window
    # We group by EmployeeID, then count how many records fall in each rolling window of length `"{window_minutes}min"`
    df["swipe_count_rolling"] = (
        df.groupby("EmployeeID")["EmployeeID"]
          .rolling(f"{window_minutes}min")
          .count()
          .reset_index(level=0, drop=True)
    )

    # Mark anomaly if swipe_count_rolling > max_swipes
    df["anomaly"] = df["swipe_count_rolling"] > max_swipes

    # Reset index so that LocaleMessageTime is once again a column
    df = df.reset_index()

    return df


def label_card_share(df: pd.DataFrame, window: timedelta = timedelta(minutes=5)) -> pd.DataFrame:
    """
    Label 'card_share' when two different EmployeeIDs use the same CardNumber within `window`.
    """
    df = df.copy()
    df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")
    df = df.sort_values("LocaleMessageTime")

    # Shift by previous swipe on same CardNumber
    df["prev_employee"] = df.groupby("CardNumber")["EmployeeID"].shift(1)
    df["prev_time"]     = df.groupby("CardNumber")["LocaleMessageTime"].shift(1)

    df["card_share"] = (
        (df["EmployeeID"] != df["prev_employee"]) &
        (df["LocaleMessageTime"] - df["prev_time"] <= window)
    )
    return df


def label_duration(df: pd.DataFrame) -> pd.DataFrame:
    """
    Compute duration per day and label 'short_stay' (<1h) and 'long_stay' (>10h).
    Returns a DataFrame grouped by (EmployeeID, Dateonly) with:
      first_swipe, last_swipe, swipe_count, duration_hours, short_stay, long_stay
    """
    df = df.copy()
    df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")

    # Aggregate per EmployeeID & Dateonly
    agg = (
        df.groupby(["EmployeeID", "Dateonly"])["LocaleMessageTime"]
          .agg(["min", "max", "count"])
          .rename(columns={"min": "first_swipe", "max": "last_swipe", "count": "swipe_count"})
          .reset_index()
    )
    agg["duration_hours"] = (agg["last_swipe"] - agg["first_swipe"]).dt.total_seconds() / 3600
    agg["short_stay"] = agg["duration_hours"] < 1
    agg["long_stay"]  = agg["duration_hours"] > 10

    return agg


def label_low_swipe(df: pd.DataFrame) -> pd.DataFrame:
    """
    Label 'one_swipe' or 'two_swipe' if total swipes per day ≤ 2.
    Returns a DataFrame with (EmployeeID, Dateonly, swipe_count, one_swipe, two_swipe).
    """
    df = df.copy()
    counts = (
        df.groupby(["EmployeeID", "Dateonly"])
          .size()
          .reset_index(name="swipe_count")
    )
    counts["one_swipe"] = counts["swipe_count"] == 1
    counts["two_swipe"] = counts["swipe_count"] == 2

    return counts


def label_exit_first(df: pd.DataFrame) -> pd.DataFrame:
    """
    Label 'exit_first' if the first swipe of the day is OutDirection.
    Returns a DataFrame with (EmployeeID, Dateonly, exit_first).
    """
    df = df.copy()
    df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")
    first = (
        df.sort_values("LocaleMessageTime")
          .groupby(["EmployeeID", "Dateonly"])
          .first()
          .reset_index()
    )
    first["exit_first"] = first["Direction"] == "OutDirection"
    return first[["EmployeeID", "Dateonly", "exit_first"]]


def label_simultaneous(df: pd.DataFrame) -> pd.DataFrame:
    """
    Label 'simultaneous' when two different EmployeeIDs swipe the same Door at exactly the same time.
    Returns the original DataFrame merged with a new 'simultaneous' column (True/False).
    """
    df = df.copy()
    df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")

    # Count how many distinct EmployeeIDs share the same (Door, LocaleMessageTime)
    dup = (
        df.groupby(["Door", "LocaleMessageTime"])["EmployeeID"]
          .nunique()
          .reset_index(name="user_count")
    )
    dup["simultaneous"] = dup["user_count"] > 1

    # Merge the boolean back onto the main df
    df = df.merge(
        dup[["Door", "LocaleMessageTime", "simultaneous"]],
        on=["Door", "LocaleMessageTime"],
        how="left"
    )
    df["simultaneous"] = df["simultaneous"].fillna(False)
    return df





(venv) PS C:\Users\W0024618\Desktop\ai-employee-security\src> python train.py


(venv) PS C:\Users\W0024618\Desktop\ai-employee-security> uvicorn src.api:app --reload








PS C:\Users\W0024618\Desktop\ai-employee-security> ^C
PS C:\Users\W0024618\Desktop\ai-employee-security> ^C
PS C:\Users\W0024618\Desktop\ai-employee-security> cd C:\Users\W0024618\Desktop\ai-employee-security
PS C:\Users\W0024618\Desktop\ai-employee-security> python -m venv venv
Unable to copy 'C:\\Program Files\\Python313\\Lib\\venv\\scripts\\nt\\venvlauncher.exe' to 'C:\\Users\\W0024618\\Desktop\\ai-employee-security\\venv\\Scripts\\python.exe'
PS C:\Users\W0024618\Desktop\ai-employee-security> venv\Scripts\activate
(venv) PS C:\Users\W0024618\Desktop\ai-employee-security> pip install --upgrade pip
Requirement already satisfied: pip in c:\users\w0024618\desktop\ai-employee-security\venv\lib\site-packages (25.1.1)
(venv) PS C:\Users\W0024618\Desktop\ai-employee-security> pip install pandas scikit-learn joblib fastapi uvicorn python‐dotenv pyodbc sqlalchemy
ERROR: Invalid requirement: 'python‐dotenv': Expected end or semicolon (after name and no valid version specifier)
    python‐dotenv
          ^
(venv) PS C:\Users\W0024618\Desktop\ai-employee-security> cd src
(venv) PS C:\Users\W0024618\Desktop\ai-employee-security\src> python extract.py
⏱️  Detected timestamp column: 'LocaleMessageTime'
C:\Users\W0024618\Desktop\ai-employee-security\src\extract.py:40: UserWarning: Could not infer format, so each element will be parsed individually, falling back to `dateutil`. To ensure parsing is consistent and as-expected, please specify a format.
  df["LocaleMessageTime"] = pd.to_datetime(
✅ Rows loaded: 310531
     LocaleMessageTime    Dateonly Swipe_Time EmployeeID        ObjectName1        PersonnelType  CardNumber AdmitCode     Direction                                               Door Rejection_Type
21 2025-05-31 17:29:00  2025-05-31   17:29:00          0   Vasulkar, Sachin  Property Management      410317     Admit   InDirection             APAC_IN_PUN_PODIUM_ST2 DOOR 2 (YELLOW)            NaN
22 2025-05-31 16:01:00  2025-05-31   16:01:00          0   Vasulkar, Sachin  Property Management      410317     Admit   InDirection     APAC_IN_PUN_PODIUM_YELLOW_RECEPTION ENTRY-DOOR            NaN
23 2025-05-31 09:39:00  2025-05-31   09:39:00          0       Maurya, Anil  Property Management      410377     Admit  OutDirection      APAC_IN_PUN_PODIUM_GREEN_RECEPTION ENTRY-DOOR            NaN
24 2025-05-31 09:30:00  2025-05-31   09:30:00          0       Maurya, Anil  Property Management      410377     Admit   InDirection              APAC_IN_PUN_PODIUM_ST3 DOOR 2 (GREEN)            NaN
25 2025-05-31 08:30:00  2025-05-31   08:30:00   W0021569  Kamble, Babasaheb           Contractor      615768     Admit   InDirection  APAC_IN_PUN_PODIUM_YELLOW_REPRO STORE-DOOR Res...            NaN
✅ Saved DataFrame with 310531 rows to C:\Users\W0024618\Desktop\ai-employee-security\data\logs.pkl
(venv) PS C:\Users\W0024618\Desktop\ai-employee-security\src> cd src
cd : Cannot find path 'C:\Users\W0024618\Desktop\ai-employee-security\src\src' because it does not exist.
At line:1 char:1
+ cd src
+ ~~~~~~
    + CategoryInfo          : ObjectNotFound: (C:\Users\W00246...ecurity\src\src:String) [Set-Location], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.SetLocationCommand

(venv) PS C:\Users\W0024618\Desktop\ai-employee-security\src> python train.py
Traceback (most recent call last):
  File "C:\Users\W0024618\Desktop\ai-employee-security\src\train.py", line 188, in <module>
    build_and_save_model()
    ~~~~~~~~~~~~~~~~~~~~^^
  File "C:\Users\W0024618\Desktop\ai-employee-security\src\train.py", line 124, in build_and_save_model
    df_labeled = apply_all_labelers(df)
  File "C:\Users\W0024618\Desktop\ai-employee-security\src\train.py", line 39, in apply_all_labelers
    df = label_anomaly(df)
  File "C:\Users\W0024618\Desktop\ai-employee-security\src\labelers.py", line 14, in label_anomaly
    .rolling(f"{window_minutes}min")
     ~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\W0024618\Desktop\ai-employee-security\venv\Lib\site-packages\pandas\core\groupby\groupby.py", line 3879, in rolling
    return RollingGroupby(
        self._selected_obj,
    ...<3 lines>...
        **kwargs,
    )
  File "C:\Users\W0024618\Desktop\ai-employee-security\venv\Lib\site-packages\pandas\core\window\rolling.py", line 713, in __init__
    super().__init__(obj, *args, **kwargs)
    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\W0024618\Desktop\ai-employee-security\venv\Lib\site-packages\pandas\core\window\rolling.py", line 170, in __init__
    self._validate()
    ~~~~~~~~~~~~~~^^
  File "C:\Users\W0024618\Desktop\ai-employee-security\venv\Lib\site-packages\pandas\core\window\rolling.py", line 1914, in _validate
    raise ValueError("window must be an integer 0 or greater")
ValueError: window must be an integer 0 or greater
(venv) PS C:\Users\W0024618\Desktop\ai-employee-security\src>












