Give me updated 


# src/labelers.py

import pandas as pd
from datetime import timedelta

def label_anomaly(df: pd.DataFrame, window_minutes: int = 10, max_swipes: int = 5) -> pd.DataFrame:
    """
    Label 'anomaly' if an employee has more than `max_swipes` within `window_minutes`.
    This version sets LocaleMessageTime as the index so that .rolling("10min") works correctly.
    """
    # Ensure proper datetime and sort
    df = df.copy()
    df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")
    df = df.dropna(subset=["LocaleMessageTime"])
    df = df.sort_values(["EmployeeID", "LocaleMessageTime"])

    # Temporarily set the index to LocaleMessageTime (DatetimeIndex)
    df = df.set_index("LocaleMessageTime")

    # Compute rolling count of swipes per EmployeeID over x-minute window
    # We group by EmployeeID, then count how many records fall in each rolling window of length `"{window_minutes}min"`
    df["swipe_count_rolling"] = (
        df.groupby("EmployeeID")["EmployeeID"]
          .rolling(f"{window_minutes}min")
          .count()
          .reset_index(level=0, drop=True)
    )

    # Mark anomaly if swipe_count_rolling > max_swipes
    df["anomaly"] = df["swipe_count_rolling"] > max_swipes

    # Reset index so that LocaleMessageTime is once again a column
    df = df.reset_index()

    return df


def label_card_share(df: pd.DataFrame, window: timedelta = timedelta(minutes=5)) -> pd.DataFrame:
    """
    Label 'card_share' when two different EmployeeIDs use the same CardNumber within `window`.
    """
    df = df.copy()
    df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")
    df = df.sort_values("LocaleMessageTime")

    # Shift by previous swipe on same CardNumber
    df["prev_employee"] = df.groupby("CardNumber")["EmployeeID"].shift(1)
    df["prev_time"]     = df.groupby("CardNumber")["LocaleMessageTime"].shift(1)

    df["card_share"] = (
        (df["EmployeeID"] != df["prev_employee"]) &
        (df["LocaleMessageTime"] - df["prev_time"] <= window)
    )
    return df


def label_duration(df: pd.DataFrame) -> pd.DataFrame:
    """
    Compute duration per day and label 'short_stay' (<1h) and 'long_stay' (>10h).
    Returns a DataFrame grouped by (EmployeeID, Dateonly) with:
      first_swipe, last_swipe, swipe_count, duration_hours, short_stay, long_stay
    """
    df = df.copy()
    df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")

    # Aggregate per EmployeeID & Dateonly
    agg = (
        df.groupby(["EmployeeID", "Dateonly"])["LocaleMessageTime"]
          .agg(["min", "max", "count"])
          .rename(columns={"min": "first_swipe", "max": "last_swipe", "count": "swipe_count"})
          .reset_index()
    )
    agg["duration_hours"] = (agg["last_swipe"] - agg["first_swipe"]).dt.total_seconds() / 3600
    agg["short_stay"] = agg["duration_hours"] < 1
    agg["long_stay"]  = agg["duration_hours"] > 10

    return agg


def label_low_swipe(df: pd.DataFrame) -> pd.DataFrame:
    """
    Label 'one_swipe' or 'two_swipe' if total swipes per day â‰¤ 2.
    Returns a DataFrame with (EmployeeID, Dateonly, swipe_count, one_swipe, two_swipe).
    """
    df = df.copy()
    counts = (
        df.groupby(["EmployeeID", "Dateonly"])
          .size()
          .reset_index(name="swipe_count")
    )
    counts["one_swipe"] = counts["swipe_count"] == 1
    counts["two_swipe"] = counts["swipe_count"] == 2

    return counts


def label_exit_first(df: pd.DataFrame) -> pd.DataFrame:
    """
    Label 'exit_first' if the first swipe of the day is OutDirection.
    Returns a DataFrame with (EmployeeID, Dateonly, exit_first).
    """
    df = df.copy()
    df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")
    first = (
        df.sort_values("LocaleMessageTime")
          .groupby(["EmployeeID", "Dateonly"])
          .first()
          .reset_index()
    )
    first["exit_first"] = first["Direction"] == "OutDirection"
    return first[["EmployeeID", "Dateonly", "exit_first"]]


def label_simultaneous(df: pd.DataFrame) -> pd.DataFrame:
    """
    Label 'simultaneous' when two different EmployeeIDs swipe the same Door at exactly the same time.
    Returns the original DataFrame merged with a new 'simultaneous' column (True/False).
    """
    df = df.copy()
    df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")

    # Count how many distinct EmployeeIDs share the same (Door, LocaleMessageTime)
    dup = (
        df.groupby(["Door", "LocaleMessageTime"])["EmployeeID"]
          .nunique()
          .reset_index(name="user_count")
    )
    dup["simultaneous"] = dup["user_count"] > 1

    # Merge the boolean back onto the main df
    df = df.merge(
        dup[["Door", "LocaleMessageTime", "simultaneous"]],
        on=["Door", "LocaleMessageTime"],
        how="left"
    )
    df["simultaneous"] = df["simultaneous"].fillna(False)
    return df

