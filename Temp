import pyodbc
conn = pyodbc.connect(
    "DRIVER={ODBC Driver 17 for SQL Server};"
    "SERVER=SRVWUDEN0890V;"
    "DATABASE=ACVSUJournal_00010020;"
    "UID=GSOC_Test;"
    "PWD=your_actual_password_here;"
    "TrustServerCertificate=yes;"
)
print("✅ Connection successful")







{
  "detail": "(pyodbc.InterfaceError) ('28000', \"[28000] [Microsoft][ODBC Driver 17 for SQL Server][SQL Server]Login failed for user 'GSOC_Test'. (18456) (SQLDriverConnect); [28000] [Microsoft][ODBC Driver 17 for SQL Server][SQL Server]Login failed for user 'GSOC_Test'. (18456)\")\n(Background on this error at: https://sqlalche.me/e/20/rvf5)"
}



python -m pip install --upgrade pip




C:\Users\W0024618\Desktop\ai-employee-security\myapp\__init__.py



C:\Users\W0024618\Desktop\ai-employee-security\main.py




# main.py

from fastapi import FastAPI
from myapp.data_controller import router as data_router

app = FastAPI(
    title="AI Employee Security API",
    description="Endpoints for fetching raw access logs for model training.",
    version="1.0"
)

# Prefix all routes in data_controller under /api
app.include_router(data_router, prefix="/api")


# (Optional) A simple root health check:
@app.get("/", tags=["Root"])
def read_root():
    return {"message": "AI Employee Security API is running."}





cd C:\Users\W0024618\Desktop\ai-employee-security
venv\Scripts\activate     # or however you activate your venv
pip install fastapi uvicorn sqlalchemy pyodbc python-dotenv












pip install fastapi uvicorn sqlalchemy pyodbc python-dotenv



from fastapi import FastAPI
from myapp.data_controller import router as data_router

app = FastAPI()

# Mount the “/api” path to our data_controller
app.include_router(data_router, prefix="/api")



uvicorn main:app --reload






# myapp/data_controller.py

from fastapi import APIRouter, HTTPException
from sqlalchemy import text
from sqlalchemy.engine import Result
from typing import List, Dict
from .db import get_engine   # ✅ Correct relative import

router = APIRouter()


@router.get("/raw-data", response_model=List[Dict])
async def fetch_raw_access_logs():
    """
    Execute the SQL query against ACVSUJournal_00010020 as described,
    returning all rows needed for model training.
    """
    engine = get_engine()

    # This is the exact query you provided (comments removed).
    sql_query = """
    WITH CombinedQuery AS(
        SELECT 
            DATEADD(
              MINUTE, 
              -1 * t1.[MessageLocaleOffset], 
              t1.[MessageUTC]
            ) AS LocaleMessageTime,
            t1.ObjectName1,
            t1.PartitionName2 AS location,
            t5_card.CardNumber,
            t5_admit.value AS AdmitCode,
            t5_dir.value AS Direction,
            t1.ObjectName2,
            t5_rej.value AS Rejection_Type,
            CASE 
              WHEN t3.Name IN ('Contractor', 'Terminated Contractor') 
              THEN t2.Text12
              ELSE CAST(t2.Int1 AS NVARCHAR)
            END AS EmployeeID,
            t3.Name AS PersonnelType,
            t1.MessageType,
            t1.XmlGUID
        FROM [ACVSUJournal_00010020].[dbo].[ACVSUJournalLog] AS t1
        LEFT JOIN [ACVSCore].[Access].[Personnel] AS t2 
          ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3 
          ON t2.[PersonnelTypeId] = t3.[ObjectID]
        LEFT JOIN [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxmlShred] AS t5_admit
          ON t1.XmlGUID = t5_admit.GUID 
          AND t5_admit.Name = 'AdmitCode'
        LEFT JOIN [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxmlShred] AS t5_dir
          ON t1.XmlGUID = t5_dir.GUID 
          AND t5_dir.Value IN ('InDirection', 'OutDirection')
        LEFT JOIN [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxml] AS t_xml
          ON t1.XmlGUID = t_xml.GUID
        LEFT JOIN (
            SELECT GUID, [value]
            FROM [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxmlShred]
            WHERE [Name] IN ('Card', 'CHUID')
        ) AS SCard 
          ON t1.XmlGUID = SCard.GUID
        OUTER APPLY (
            SELECT COALESCE(
                TRY_CAST(t_xml.XmlMessage AS XML)
                    .value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
                TRY_CAST(t_xml.XmlMessage AS XML)
                    .value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
                SCard.[value]
            ) AS CardNumber
        ) AS t5_card
        LEFT JOIN [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxmlShred] AS t5_Rej
          ON t1.XmlGUID = t5_Rej.GUID 
          AND t5_Rej.Name = 'RejectCode'
        WHERE 
            t1.MessageType IN ('CardAdmitted', 'CardRejected')
            AND t1.PartitionName2 = 'APAC.Default'
            AND CONVERT(
                date, 
                DATEADD(
                  MINUTE, 
                  -1 * t1.MessageLocaleOffset, 
                  t1.MessageUTC
                )
            ) >= '2025-01-01'
    )
    SELECT
        LocaleMessageTime,
        CONVERT(date, LocaleMessageTime)         AS Dateonly,
        CONVERT(time(0), LocaleMessageTime)      AS Swipe_Time,
        EmployeeID,
        ObjectName1,
        PersonnelType,
        CardNumber,
        AdmitCode,
        Direction,
        ObjectName2 AS Door,
        Rejection_Type
    FROM CombinedQuery
    ORDER BY LocaleMessageTime DESC;
    """

    try:
        with engine.connect() as conn:
            result: Result = conn.execute(text(sql_query))
            rows = [dict(row) for row in result.fetchall()]
        return rows

    except Exception as exc:
        # If anything goes wrong (credentials, network, etc.), return a 500
        raise HTTPException(status_code=500, detail=str(exc))




# myapp/db.py

import os
from sqlalchemy import create_engine
from sqlalchemy.engine import Engine
from urllib.parse import quote_plus
from dotenv import load_dotenv

# Load environment variables from the .env file in the project root
load_dotenv(os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir, ".env")))

DB_DRIVER   = os.getenv("DB_DRIVER", "ODBC Driver 17 for SQL Server")
DB_SERVER   = os.getenv("DB_SERVER", "")
DB_DATABASE = os.getenv("DB_DATABASE", "")
DB_USER     = os.getenv("DB_USER", "")
DB_PASSWORD = os.getenv("DB_PASSWORD", "")

def get_engine() -> Engine:
    """
    Create and return a SQLAlchemy Engine connected to SQL Server via pyodbc.
    """
    # Build the ODBC connection string (URL‐encoded)
    odbc_str = (
        "DRIVER={driver};"
        "SERVER={server};"
        "DATABASE={database};"
        "UID={user};"
        "PWD={password};"
        "TrustServerCertificate=yes;"
    ).format(
        driver=DB_DRIVER,
        server=DB_SERVER,
        database=DB_DATABASE,
        user=DB_USER,
        password=DB_PASSWORD,
    )

    # SQLAlchemy connection URL for MSSQL + pyodbc
    connection_url = f"mssql+pyodbc:///?odbc_connect={quote_plus(odbc_str)}"

    engine = create_engine(connection_url, fast_executemany=True)
    return engine








Give me Updated py files carefully
C:\Users\W0024618\Desktop\ai-employee-security\myapp

# src/data_controller.py

from fastapi import APIRouter, HTTPException
from sqlalchemy import text
from sqlalchemy.engine import Result
from typing import List, Dict
from .db import get_engine  # ✅ correct

router = APIRouter()


@router.get("/raw-data", response_model=List[Dict])
async def fetch_raw_access_logs():
    """
    Execute the SQL query against ACVSUJournal_00010020 as described, returning
    all rows needed for model training. 
    """
    engine = get_engine()

    # This is your full query, exactly as given (just remove comments).
    sql_query = """
    WITH CombinedQuery AS(
        SELECT 
            DATEADD(
              MINUTE, 
             -1 * t1.[MessageLocaleOffset], 
              t1.[MessageUTC]
            ) AS LocaleMessageTime,
            t1.ObjectName1,
            t1.PartitionName2 AS location,
            t5_card.CardNumber,
            t5_admit.value AS AdmitCode,
            t5_dir.value AS Direction,
            t1.ObjectName2,
            t5_rej.value AS Rejection_Type,
            CASE 
              WHEN t3.Name IN ('Contractor', 'Terminated Contractor') 
              THEN t2.Text12
              ELSE CAST(t2.Int1 AS NVARCHAR)
            END AS EmployeeID,
            t3.Name AS PersonnelType,
            t1.MessageType,
            t1.XmlGUID
        FROM [ACVSUJournal_00010020].[dbo].[ACVSUJournalLog] AS t1
        LEFT JOIN [ACVSCore].[Access].[Personnel] AS t2 
          ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] AS t3 
          ON t2.[PersonnelTypeId] = t3.[ObjectID]
        LEFT JOIN [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxmlShred] AS t5_admit
          ON t1.XmlGUID = t5_admit.GUID 
          AND t5_admit.Name = 'AdmitCode'
        LEFT JOIN [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxmlShred] AS t5_dir
          ON t1.XmlGUID = t5_dir.GUID 
          AND t5_dir.Value IN ('InDirection', 'OutDirection')
        LEFT JOIN [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxml] AS t_xml
          ON t1.XmlGUID = t_xml.GUID
        LEFT JOIN (
            SELECT GUID, [value]
            FROM [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxmlShred]
            WHERE [Name] IN ('Card', 'CHUID')
        ) AS SCard 
          ON t1.XmlGUID = SCard.GUID
        OUTER APPLY (
            SELECT COALESCE(
                TRY_CAST(t_xml.XmlMessage AS XML)
                    .value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
                TRY_CAST(t_xml.XmlMessage AS XML)
                    .value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
                SCard.[value]
            ) AS CardNumber
        ) AS t5_card
        LEFT JOIN [ACVSUJournal_00010020].[dbo].[ACVSUJournalLogxmlShred] AS t5_Rej
          ON t1.XmlGUID = t5_Rej.GUID 
          AND t5_Rej.Name = 'RejectCode'
        WHERE 
            t1.MessageType IN ('CardAdmitted', 'CardRejected')
            AND t1.PartitionName2 = 'APAC.Default'
            AND CONVERT(
                date, 
                DATEADD(
                  MINUTE, 
                 -1 * t1.MessageLocaleOffset, 
                  t1.MessageUTC
                )
            ) >= '2025-01-01'
    )
    SELECT
        LocaleMessageTime,
        CONVERT(date, LocaleMessageTime)         AS Dateonly,
        CONVERT(time(0), LocaleMessageTime)      AS Swipe_Time,
        EmployeeID,
        ObjectName1,
        PersonnelType,
        CardNumber,
        AdmitCode,
        Direction,
        ObjectName2 AS Door,
        Rejection_Type
    FROM CombinedQuery
    ORDER BY LocaleMessageTime DESC;
    """

    try:
        with engine.connect() as conn:
            result: Result = conn.execute(text(sql_query))
            rows = [dict(row) for row in result.fetchall()]
        return rows

    except Exception as exc:
        # If anything goes wrong (credentials, network, etc.), return a 500
        raise HTTPException(status_code=500, detail=str(exc))



C:\Users\W0024618\Desktop\ai-employee-security\myapp\db.py
# src/db.py

import os
from sqlalchemy import create_engine
from sqlalchemy.engine import Engine
from urllib.parse import quote_plus
from dotenv import load_dotenv

# Load .env from project root
load_dotenv(os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir, ".env")))

DB_DRIVER   = os.getenv("DB_DRIVER", "ODBC Driver 17 for SQL Server")
DB_SERVER   = os.getenv("DB_SERVER", "")
DB_DATABASE = os.getenv("DB_DATABASE", "")
DB_USER     = os.getenv("DB_USER", "")
DB_PASSWORD = os.getenv("DB_PASSWORD", "")

def get_engine() -> Engine:
    """
    Return a SQLAlchemy Engine connected to the SQL Server using pyodbc.
    """
    # Build the connection string. Using quote_plus for URL‐encoding credentials.
    odbc_str = (
        "DRIVER={driver};"
        "SERVER={server};"
        "DATABASE={database};"
        "UID={user};"
        "PWD={password};"
        "TrustServerCertificate=yes;"
    ).format(
        driver=DB_DRIVER,
        server=DB_SERVER,
        database=DB_DATABASE,
        user=DB_USER,
        password=DB_PASSWORD,
    )
    # SQLAlchemy URL for MSSQL + pyodbc
    connection_url = f"mssql+pyodbc:///?odbc_connect={quote_plus(odbc_str)}"

    engine = create_engine(connection_url, fast_executemany=True)
    return engine

