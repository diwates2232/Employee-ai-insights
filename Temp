// controllers/liveOccupancyController.js

const { DateTime }   = require('luxon');
const { poolConnect, pool, sql } = require('../config/db');
const doorZoneMap    = require('../data/doorZoneMap');
const zoneFloorMap   = require('../data/zoneFloorMap');

// track which door→zone keys we've already warned on
const warnedKeys = new Set();

/** Normalize rawDoor & rawDir into the same key format used by doorZoneMap */
function normalizeZoneKey(rawDoor, rawDir) {
  const base = String(rawDoor || '')
    .trim()
    .replace(/\s+/g, ' ')
    .toUpperCase();
  const dir = /IN/i.test(rawDir) ? 'InDirection' : 'OutDirection';
  return `${base}___${dir}`;
}

/**
 * Map a swipe’s door+direction → zone.
 * 1) Try the explicit map.
 * 2) If it starts with APAC_IN_PUN, pull out floor & zone from the name.
 * 3) Otherwise warn once and return 'Unknown Zone'.
 */
function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeZoneKey(rawDoor, rawDir);
  if (doorZoneMap[key]) {
    return doorZoneMap[key];
  }

  const up = String(rawDoor || '').toUpperCase();
  if (up.startsWith('APAC_IN_PUN_')) {
    // after APAC_IN_PUN_
    const rest = up.slice('APAC_IN_PUN_'.length);
    // attempt parenthesized zone: e.g. "... (RED)"
    const paren = rest.match(/\(([^)]+)\)/);
    let zone, floor;
    if (paren) {
      zone = paren[1];
    } else {
      // otherwise split on '_' → first is floor, second is likely zone
      const parts = rest.split('_').filter(Boolean);
      floor = parts[0];              // e.g. PODIUM, 2NDFLR, TOWER B
      zone  = parts[1] || 'Unknown'; // e.g. RED, GSOC, RECEPTION
    }
    return zone;
  }

  if (!warnedKeys.has(key)) {
    console.warn('⛔ Unmapped door-zone key:', key);
    warnedKeys.add(key);
  }
  return 'Unknown Zone';
}

// ... the rest of your file remains exactly the same ...

// (fetchNewEvents, buildOccupancy, buildVisitedToday, exports.getLiveOccupancy, etc.)










Read Below file carefully this is our Pune File All file Working Successfully.
in Console We are getting Unmapped door list ,its Fine Some Door are not get map as per current logic so We dont meet excat count,
if possible Can we Write extra condtion for unmapped door and all dor.

APAC_IN_PUN_PODIUM_RED_IDF ROOM-02-Restricted Door
APAC_IN_PUN_PODIUM_ST2 DOOR 1 (RED)
APAC_IN_PUN_PODIUM_RED_MAIN LIFT LOBBY ENTRY 1-DOOR
APAC_IN_PUN_PODIUM_YELLOW_IT STORE ROOM-DOOR Restricted door
APAC_IN_PUN_PODIUM_GSOC DOOR Restricted door
APAC_IN_PUN_2NDFLR_IDF ROOM_10:05:86 Restricted Door
APAC_IN_PUN_2NDFLR_UPS/ELEC ROOM Restricted Door_10:05:FE
APAC_IN_PUN_TOWER B_ST5_WKS SIDE DOOR
APAC_IN_PUN_TOWER B_RECEPTION LEFT DOOR

This is sample door list of pune
to display Unknown Zone or Floor Can we Double Check Door List.and Display correct zone and Floor for each entry.

APAC_IN_PUN_PODIUM_RED_IDF ROOM-02-Restricted Door
APAC_IN_PUN_PODIUM_ST2 DOOR 1 (RED)
APAC_IN_PUN_PODIUM_RED_MAIN LIFT LOBBY ENTRY 1-DOOR
APAC_IN_PUN_PODIUM_YELLOW_IT STORE ROOM-DOOR Restricted door
APAC_IN_PUN_PODIUM_GSOC DOOR Restricted door 

let see all  Podium floor door are in same Format its Clearly mention Podium is Floor name and RED is Zone name , APAC_IN_PUN_PODIUM_ST2 DOOR 1 (RED) for this type of door
in bracket (RED) mentioned is shows Zone details 
APAC_IN_PUN_PODIUM_GSOC DOOR Restricted door GSOC is only one door in podium floor if we get entry for this create new zone name as GSOC and Floor is Podium.

APAC_IN_PUN_2NDFLR_IDF ROOM_10:05:86 Restricted Door
APAC_IN_PUN_2NDFLR_UPS/ELEC ROOM Restricted Door_10:05:FE
let see above 2NDFLR door all 2NDFLR door is same format .

APAC_IN_PUN_TOWER B_ST5_WKS SIDE DOOR
APAC_IN_PUN_TOWER B_RECEPTION LEFT DOOR
same format for TOWER B 
if door name has full information then why create unkonown zone or Floor .

Use Strong logic for this and give me updated js file carefully









// controllers/liveOccupancyController.js


const { DateTime }   = require('luxon');
const { poolConnect, pool, sql } = require('../config/db');
const doorZoneMap    = require('../data/doorZoneMap');
const zoneFloorMap   = require('../data/zoneFloorMap');

// track which door→zone keys we've already warned on
const warnedKeys = new Set();

/** Normalize rawDoor & rawDir into the same key format used by doorZoneMap */
function normalizeZoneKey(rawDoor, rawDir) {
  const base = String(rawDoor || '')
    .trim()
    .replace(/\s+/g, ' ')
    .toUpperCase();
  const dir = /IN/i.test(rawDir) ? 'InDirection' : 'OutDirection';
  return `${base}___${dir}`;
}

/** Map a swipe’s door+direction → zone, warning once on any unmapped key */
function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeZoneKey(rawDoor, rawDir);

  if (doorZoneMap[key]) {
    return doorZoneMap[key];
  }
  if (!warnedKeys.has(key)) {
    console.warn('⛔ Unmapped door-zone key:', key);
    warnedKeys.add(key);
  }

  // treat any APAC_IN_PUN door as “in office” but unknown zone
  if (String(rawDoor || '').toUpperCase().startsWith('APAC_IN_PUN')) {
    return 'Unknown Zone';
  }
  return 'Unknown Zone';
}

/** Fetch all swipe events since `since` (UTC) */
async function fetchNewEvents(since) {
  await poolConnect;
  const req = pool.request();
  req.input('since', sql.DateTime2, since);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, t1.MessageLocaleOffset, t1.MessageUTC) >= @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return recordset;
}


/** Build the live‐occupancy snapshot from allEvents */
async function buildOccupancy(allEvents) {
  const current      = {};
  const uniquePeople = new Map();

  for (const evt of allEvents) {
    const {
      EmployeeID, PersonGUID,
      ObjectName1, PersonnelType,
      CardNumber, Dateonly,
      Swipe_Time, Direction, Door
    } = evt;

    const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
    const zone     = mapDoorToZone(Door, Direction);

    // “Out of office” actually evicts
    if (Direction === 'OutDirection' && zone === 'Out of office') {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
      continue;
    }

    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = { Dateonly, Swipe_Time, EmployeeID, ObjectName1, CardNumber, PersonnelType, zone };
    } else {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
    }
  }

  // live headcounts
  let employeeCount   = 0;
  let contractorCount = 0;
  for (const pt of uniquePeople.values()) {
    if (['Employee','Terminated Personnel'].includes(pt)) employeeCount++;
    else contractorCount++;
  }

  // zone & floor aggregates
  const zoneMap = {};
  for (const emp of Object.values(current)) {
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }
  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([z, emps]) => {
      const byType = emps.reduce((acc, e) => {
        acc[e.PersonnelType] = (acc[e.PersonnelType]||0) + 1;
        return acc;
      }, {});
      return [ z, { total: emps.length, byPersonnelType: byType, employees: emps } ];
    })
  );

  const floorMap = {};
  for (const [z,d] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[z] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += d.total;
    for (const [pt,c] of Object.entries(d.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt]||0) + c;
    }
  }

  return {
    asOf:             new Date().toISOString(),
    summary:          Object.entries(zoneDetails).map(([z,d])=>({ zone: z, count: d.total })),
    zoneBreakdown:    Object.entries(zoneDetails).map(([z,d])=>({ zone: z, ...d.byPersonnelType, total: d.total })),
    floorBreakdown:   Object.entries(floorMap).map(([f,d])=>({ floor: f, ...d.byPersonnelType, total: d.total })),
    details:          zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
    personnelBreakdown:[
      { personnelType:'Employee',   count: employeeCount   },
      { personnelType:'Contractor', count: contractorCount }
    ]
  };
}

/** Build “visited today” from the same in‐memory stream */
function buildVisitedToday(allEvents) {
  // IST “today” string
  const today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');

  // only today's InDirection swipes
  const todayIns = allEvents.filter(evt => {
    if (evt.Direction !== 'InDirection' || !evt.LocaleMessageTime) return false;
    const swipeDate = DateTime
      .fromJSDate(evt.LocaleMessageTime, { zone:'Asia/Kolkata' })
      .toFormat('yyyy-LL-dd');
    return swipeDate === today;
  });

  // dedupe by PersonGUID → keep latest
  const dedup = new Map();
  for (const e of todayIns) {
    const prev = dedup.get(e.PersonGUID);
    if (!prev || e.LocaleMessageTime > prev.LocaleMessageTime) {
      dedup.set(e.PersonGUID, e);
    }
  }

  const finalList   = Array.from(dedup.values());
  const employees   = finalList.filter(e =>
    !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management']
      .includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}

/** Server‐Sent‐Events endpoint */
exports.getLiveOccupancy = async (req, res) => {
  try {
    await poolConnect;

    res.writeHead(200, {
      'Content-Type':  'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection':    'keep-alive'
    });
    res.write('\n');

    // pull last 24h on startup
    let lastSeen = new Date(Date.now() - 24*60*60*1000);
    const events = [];

    const push = async () => {
      const fresh = await fetchNewEvents(lastSeen);
      if (fresh.length) {
        lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
        events.push(...fresh);
      }

      // build occupancy + today counts
      const occupancy  = await buildOccupancy(events);
      const todayStats = buildVisitedToday(events);

      occupancy.totalVisitedToday = todayStats.total;
      occupancy.visitedToday      = {
        employees:   todayStats.employees,
        contractors: todayStats.contractors,
        total:       todayStats.total
      };

      res.write(`data: ${JSON.stringify(occupancy)}\n\n`);
    };

    await push();
    const timer = setInterval(push, 1000);
    req.on('close', () => clearInterval(timer));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};
