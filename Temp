// src/components/SummaryChart.jsx

import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList
} from 'recharts';
import { Card } from 'react-bootstrap';

// Gradients per zone (fallback to DEFAULT_GRADIENT if missing)
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c']
};

// Solid‐color fallbacks (if a zone isn’t in ZONE_GRADIENTS)
const SOLID_COLORS = [
  '#FFD100', '#009E60', '#FF6F61',
  '#58595B', '#FFB800', '#C75D00'
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  /**
   * Build a "pieData" array in which each slice has `value: 1`
   * (so every slice is equal width in the semi‐donut), but keep
   * the real `count` in entry.count so we can show it inside each segment.
   *
   * We call useMemo at the top unconditionally (even if summary is empty),
   * satisfying React Hooks’ “same-order” requirement.
   */
  const pieData = useMemo(
    () =>
      summary.map((z) => ({
        name:  z.zone,
        value: 1,       // forces equal angles
        count: z.count  // actual numeric count
      })),
    [summary]
  );

  // If there's no summary data, bail out early:
  if (!summary.length) {
    return <Card body>No zone data available</Card>;
  }

  // Custom tooltip: shows the true count under each slice on hover
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000'
        }}
      >
        <div><strong>Zone:</strong> {name}</div>
        <div style={{ marginTop: 4 }}><strong>Count:</strong> {count}</div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>
      <Card.Body style={{ height: 400, padding: 0 }}>
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem'
          }}
        >
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              {/* 1) Define gradients (or fallback) for each slice */}
              <defs>
                {pieData.map((entry) => {
                  const key = entry.name.replace(/\s+/g, '-');
                  const gradientColors = ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient
                      id={`grad-${key}`}
                      key={key}
                      x1="0"
                      y1="0"
                      x2="0"
                      y2="1"
                    >
                      <stop offset="0%" stopColor={gradientColors[0]} stopOpacity={1} />
                      <stop offset="100%" stopColor={gradientColors[1]} stopOpacity={1} />
                    </linearGradient>
                  );
                })}
              </defs>

              {/* 2) Draw the semi‐donut: startAngle=180, endAngle=0 */}
              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                startAngle={180}
                endAngle={0}
                innerRadius={60}
                outerRadius={140}
                paddingAngle={2}
                labelLine={false}
                isAnimationActive={false}
              >
                {/* 3) Place each slice’s count at the center of that slice */}
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const key = entry.name.replace(/\s+/g, '-');
                  const hasGrad = Boolean(ZONE_GRADIENTS[entry.name]);
                  const fillColor = hasGrad
                    ? `url(#grad-${key})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  const strokeColor = hasGrad
                    ? ZONE_GRADIENTS[entry.name][1]
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>

              {/* 4) Overlay a “bulb” SVG at the center of the half‐donut */}
              <svg
                x="50%"
                y="50%"
                width={100}
                height={140}
                viewBox="0 0 64 90"
                transform="translate(-50, -75)"
              >
                {/* Bulb glass */}
                <circle
                  cx="32"
                  cy="28"
                  r="30"
                  fill="#FFD100"
                  stroke="#FFC72C"
                  strokeWidth="2"
                />
                {/* Filament lines */}
                <line
                  x1="24" y1="28"
                  x2="40" y2="28"
                  stroke="#333"
                  strokeWidth="2"
                />
                <line
                  x1="28" y1="20"
                  x2="28" y2="28"
                  stroke="#333"
                  strokeWidth="2"
                />
                <line
                  x1="36" y1="20"
                  x2="36" y2="28"
                  stroke="#333"
                  strokeWidth="2"
                />
                {/* Bulb base */}
                <rect
                  x="20" y="50"
                  width="24"
                  height="12"
                  fill="#58595B"
                />
                <rect
                  x="20" y="62"
                  width="24"
                  height="6"
                  fill="#FF6F61"
                />
                {/* “Western Union Pune” text */}
                <text
                  x="32"
                  y="88"
                  textAnchor="middle"
                  fill="#FFD100"
                  fontSize="12"
                  fontWeight="bold"
                >
                  Western Union Pune
                </text>
              </svg>

              {/* 5) Attach the custom tooltip */}
              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </Card.Body>
    </Card>
  );
}








p








// src/components/SummaryChart.jsx

import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList
} from 'recharts';
import { Card } from 'react-bootstrap';

// Gradients per zone (fallback to DEFAULT_GRADIENT if missing)
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c']
};

// Solid‐color fallbacks (if a zone isn’t in ZONE_GRADIENTS)
const SOLID_COLORS = [
  '#FFD100', '#009E60', '#FF6F61',
  '#58595B', '#FFB800', '#C75D00'
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  /**
   * Build a "pieData" array in which each slice has `value: 1`
   * (so every slice is equal width in the semi‐donut), but keep
   * the real `count` in entry.count so we can show it inside each segment.
   *
   * We call useMemo at the top unconditionally (even if summary is empty),
   * satisfying React Hooks’ “same-order” requirement.
   */
  const pieData = useMemo(
    () =>
      summary.map((z) => ({
        name:  z.zone,
        value: 1,       // forces equal angles
        count: z.count  // actual numeric count
      })),
    [summary]
  );

  // If there's no summary data, bail out early:
  if (!summary.length) {
    return <Card body>No zone data available</Card>;
  }

  // Custom tooltip: shows the true count under each slice on hover
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000'
        }}
      >
        <div><strong>Zone:</strong> {name}</div>
        <div style={{ marginTop: 4 }}><strong>Count:</strong> {count}</div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>
      <Card.Body style={{ height: 400, padding: 0 }}>
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem'
          }}
        >
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              {/* 1) Define gradients (or fallback) for each slice */}
              <defs>
                {pieData.map((entry) => {
                  const key = entry.name.replace(/\s+/g, '-');
                  const gradientColors = ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient
                      id={`grad-${key}`}
                      key={key}
                      x1="0"
                      y1="0"
                      x2="0"
                      y2="1"
                    >
                      <stop offset="0%" stopColor={gradientColors[0]} stopOpacity={1} />
                      <stop offset="100%" stopColor={gradientColors[1]} stopOpacity={1} />
                    </linearGradient>
                  );
                })}
              </defs>

              {/* 2) Inline “bulb” SVG at the center */}
              <svg
                x="50%"
                y="50%"
                width={100}
                height={140}
                viewBox="0 0 64 90"
                transform="translate(-50, -75)"
              >
                {/* Bulb glass */}
                <circle
                  cx="32"
                  cy="28"
                  r="30"
                  fill="#FFD100"
                  stroke="#FFC72C"
                  strokeWidth="2"
                />
                {/* Filament lines */}
                <line
                  x1="24" y1="28"
                  x2="40" y2="28"
                  stroke="#333"
                  strokeWidth="2"
                />
                <line
                  x1="28" y1="20"
                  x2="28" y2="28"
                  stroke="#333"
                  strokeWidth="2"
                />
                <line
                  x1="36" y1="20"
                  x2="36" y2="28"
                  stroke="#333"
                  strokeWidth="2"
                />
                {/* Bulb base (dark gray + accent band) */}
                <rect
                  x="20" y=" fifty"
                  width="24"
                  height="12"
                  fill="#58595B"
                />
                <rect
                  x="20" y="62"
                  width="24"
                  height="6"
                  fill="#FF6F61"
                />
                {/* “Western Union Pune” text */}
                <text
                  x="32"
                  y="88"
                  textAnchor="middle"
                  fill="#FFD100"
                  fontSize="12"
                  fontWeight="bold"
                >
                  Western Union Pune
                </text>
              </svg>

              {/* 3) Draw the semi‐donut: startAngle=180, endAngle=0 */}
              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                startAngle={180}
                endAngle={0}
                innerRadius={60}
                outerRadius={140}
                paddingAngle={2}
                labelLine={false}
                isAnimationActive={false}
              >
                {/* 4) Place each slice’s count inside its segment */}
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const key = entry.name.replace(/\s+/g, '-');
                  const hasGrad = Boolean(ZONE_GRADIENTS[entry.name]);
                  const fillColor = hasGrad
                    ? `url(#grad-${key})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  const strokeColor = hasGrad
                    ? ZONE_GRADIENTS[entry.name][1]
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>

              {/* 5) Custom tooltip */}
              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </Card.Body>
    </Card>
  );
}















// src/components/SummaryChart.jsx
import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList
} from 'recharts';
import { Card } from 'react-bootstrap';

// Gradients per zone (fallback to DEFAULT_GRADIENT if missing)
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c']
};

// Solid-color fallbacks (if a zone isn’t listed above)
const SOLID_COLORS = [
  '#FFD100', '#009E60', '#FF6F61',
  '#58595B', '#FFB800', '#C75D00'
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  // If there’s no data, show a “no data available” card
  if (!summary.length) {
    return <Card body>No zone data available</Card>;
  }

  /**
   * Build a “pieData” array so that each slice has value=1
   * (making all angles equal). We keep the real “count” in
   * `entry.count` so we can show it inside each segment.
   */
  const pieData = useMemo(
    () =>
      summary.map((z) => ({
        name:  z.zone,
        value: 1,       // For equal slice width
        count: z.count  // Actual occupancy count
      })),
    [summary]
  );

  // Custom tooltip: show zone name + actual count
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000'
        }}
      >
        <div><strong>Zone:</strong> {name}</div>
        <div style={{ marginTop: 4 }}><strong>Count:</strong> {count}</div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>
      <Card.Body style={{ height: 400, padding: 0 }}>
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem'
          }}
        >
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              {/**
               * 1) Define a <linearGradient> for each zone (if present in ZONE_GRADIENTS),
               *    otherwise fallback to DEFAULT_GRADIENT.
               */}
              <defs>
                {pieData.map((entry) => {
                  const key = entry.name.replace(/\s+/g, '-');
                  const colors = ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient
                      id={`grad-${key}`}
                      key={key}
                      x1="0" y1="0" x2="0" y2="1"
                    >
                      <stop offset="0%"  stopColor={colors[0]} stopOpacity={1} />
                      <stop offset="100%" stopColor={colors[1]} stopOpacity={1} />
                    </linearGradient>
                  );
                })}
              </defs>

              {/**
               * 2) Overlay an inline SVG “bulb” at the center of the chart.
               *    - x="50%" / y="50%" places its top-left corner at chart center.
               *    - transform="translate(-X, -Y)" shifts it back by half the svg’s width/height.
               *    - We then add a <text> just below the bulb that reads “Western Union Pune”.
               */}
              <svg
                x="50%" 
                y="50%" 
                width={100} 
                height={140}
                viewBox="0 0 64 90"
                transform="translate(-50, -75)"
                /* 
                   The numbers above:
                   - width=100, height=140 gives us enough room for bulb + text.
                   - viewBox="0 0 64 90" means our coordinate system runs 0→64 horizontally, 0→90 vertically.
                   - translate(-50, -75) recenters the svg. 
                     (We shift left by half of width=100 → 50, and up by about 75 to center the bulb portion.)
                   You can adjust -50, -75 to fine-tune exact placement.
                */
              >
                {/**
                 * Bulb “glass” (a yellow circle)
                 */}
                <circle
                  cx="32" cy="28" r=" twenty
30"
                  fill="#FFD100"
                  stroke="#FFC72C"
                  strokeWidth="2"
                />
                {/**
                 * Filament lines (stylized)
                 */}
                <line
                  x1="24" y1="28" 
                  x2="40" y2="28"
                  stroke="#333"
                  strokeWidth="2"
                />
                <line
                  x1="28" y1="20"
                  x2="28" y2="28"
                  stroke="#333"
                  strokeWidth="2"
                />
                <line
                  x1="36" y1="20"
                  x2="36" y2="28"
                  stroke="#333"
                  strokeWidth="2"
                />
                {/**
                 * Bulb base (dark gray rectangle + accent band)
                 */}
                <rect
                  x="20" y=" thirty
50" 
                  width="24" 
                  height=" twelve
12" 
                  fill="#58595B"
                />
                <rect
                  x="20" y=" sixty
62"
                  width="24"
                  height="6"
                  fill="#FF6F61" 
                />
                {/**
                 * “Western Union Pune” text below bulb
                 */}
                <text
                  x="32" 
                  y="88" 
                  textAnchor="middle"
                  fill="#FFD100"
                  fontSize=" twelve
12"
                  fontWeight="bold"
                >
                  Western Union Pune
                </text>
              </svg>

              {/**
               * 3) Draw a half-circle Pie, startAngle=180 to endAngle=0,
               *    so it spans the top half only.
               */}
              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                startAngle={180}
                endAngle={0}
                innerRadius={60}
                outerRadius={140}
                paddingAngle={2}
                labelLine={false}
                isAnimationActive={false}
              >
                {/**
                 * 4) Show “count” inside each slice:
                 */}
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const key = entry.name.replace(/\s+/g, '-');
                  const hasGrad = Boolean(ZONE_GRADIENTS[entry.name]);
                  const fillColor = hasGrad
                    ? `url(#grad-${key})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  const strokeColor = hasGrad
                    ? (ZONE_GRADIENTS[entry.name][1])
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>

              {/**
               * 5) Finally, attach our custom tooltip:
               */}
              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </Card.Body>
    </Card>
  );
}











// src/components/SummaryChart.jsx

import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList,
} from 'recharts';
import { Card } from 'react-bootstrap';
import { FaLightbulb } from 'react-icons/fa';

// A small palette of Western Union–style accent colors for the bulb
const BULB_COLORS = [
  '#FFD100',
  '#FFB800',
  '#FF6F61',
  '#C75D00',
  '#009E60',
  '#006400',
  '#58595B',
];

// Gradients for each zone (light → dark)
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c'],
};

// Fallback solid colors if a zone isn’t in ZONE_GRADIENTS
const SOLID_COLORS = [
  '#FFD100',
  '#009E60',
  '#FF6F61',
  '#58595B',
  '#FFB800',
  '#C75D00',
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  // Build “semi-donut” data: each slice = value:1, real count stored separately
  const pieData = useMemo(
    () =>
      summary.map((z) => ({
        name: z.zone,
        value: 1,
        count: z.count,
      })),
    [summary]
  );

  // If no data, show placeholder
  if (!summary.length) {
    return <Card body>No zone data available</Card>;
  }

  // Pick a random accent color for the bulb each render
  const bulbColor =
    BULB_COLORS[Math.floor(Math.random() * BULB_COLORS.length)];

  // Tooltip: show real zone & count
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000',
        }}
      >
        <div>
          <strong>Zone:</strong> {name}
        </div>
        <div style={{ marginTop: 4 }}>
          <strong>Count:</strong> {count}
        </div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      {/* KEEP ORIGINAL HEADER TEXT */}
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>

      <Card.Body style={{ height: 480, padding: 0, position: 'relative' }}>
        {/* 
          Container holds both the bulb icon (absolutely positioned) 
          and the chart (scrollable if needed).
        */}
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem',
            position: 'relative', // so we can absolutely position the bulb inside
            overflowY: 'auto',
          }}
        >
          {/*  
            Lightbulb icon “nestled” into the top center of the donut curve.
            We offset it a bit upward so it sits between the two arcs.
          */}
          <FaLightbulb
            style={{
              position: 'absolute',
              top: '-1.25rem',
              left: '50%',
              transform: 'translateX(-50%)',
              fontSize: '3rem',
              color: bulbColor,
              zIndex: 10,
            }}
          />

          {/* 
            The half-donut sits underneath the bulb. By giving it extra top margin, 
            the bulb appears to “sit” in the curve.
          */}
          <div style={{ marginTop: '2rem', height: 'calc(100% - 2rem)' }}>
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <defs>
                  {pieData.map((entry) => {
                    const gradientKey = entry.name.replace(/\s+/g, '-');
                    const gradientColors =
                      ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                    return (
                      <linearGradient
                        id={`grad-${gradientKey}`}
                        key={`grad-${gradientKey}`}
                        x1="0"
                        y1="0"
                        x2="0"
                        y2="1"
                      >
                        <stop offset="0%" stopColor={gradientColors[0]} stopOpacity={1} />
                        <stop
                          offset="100%"
                          stopColor={gradientColors[1]}
                          stopOpacity={1}
                        />
                      </linearGradient>
                    );
                  })}
                </defs>

                <Pie
                  data={pieData}
                  dataKey="value"
                  nameKey="name"
                  startAngle={180}
                  endAngle={0}
                  innerRadius={80}
                  outerRadius={180}
                  paddingAngle={2}
                  labelLine={false}
                  isAnimationActive={false}
                >
                  <LabelList
                    dataKey="count"
                    position="inside"
                    fill="#fff"
                    style={{ fontSize: '1rem', fontWeight: 'bold' }}
                  />
                  {pieData.map((entry, idx) => {
                    const gradientKey = entry.name.replace(/\s+/g, '-');
                    const hasGradient = Boolean(ZONE_GRADIENTS[entry.name]);
                    const fillColor = hasGradient
                      ? `url(#grad-${gradientKey})`
                      : SOLID_COLORS[idx % SOLID_COLORS.length];
                    const strokeColor = hasGradient
                      ? ZONE_GRADIENTS[entry.name][1]
                      : SOLID_COLORS[idx % SOLID_COLORS.length];
                    return (
                      <Cell
                        key={`slice-${idx}`}
                        fill={fillColor}
                        stroke={strokeColor}
                        strokeWidth={1}
                      />
                    );
                  })}
                </Pie>

                <Tooltip content={renderTooltip} />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </div>

        {/* Custom legend at the very bottom */}
        <div
          style={{
            position: 'absolute',
            bottom: 0,
            left: 0,
            width: '100%',
            padding: '0.75rem 1rem',
            display: 'flex',
            flexWrap: 'wrap',
            justifyContent: 'center',
            gap: '1.5rem',
            backgroundColor: 'var(--wu-gray-dark)',
          }}
        >
          {summary.map((entry, idx) => {
            const gradientColors = ZONE_GRADIENTS[entry.zone];
            const squareColor = gradientColors
              ? gradientColors[1]
              : SOLID_COLORS[idx % SOLID_COLORS.length];
            return (
              <div
                key={`legend-${idx}`}
                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
              >
                {/* small square “plate” */}
                <div
                  style={{
                    width: '0.9rem',
                    height: '0.9rem',
                    backgroundColor: squareColor,
                    borderRadius: '2px',
                  }}
                />
                <span
                  style={{
                    color: squareColor,
                    fontSize: '0.9rem',
                    fontWeight: 500,
                  }}
                >
                  {entry.zone}
                </span>
              </div>
            );
          })}
        </div>
      </Card.Body>
    </Card>
  );
}














// src/components/SummaryChart.jsx

import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList,
} from 'recharts';
import { Card } from 'react-bootstrap';
import { FaLightbulb } from 'react-icons/fa';

// Define a small rainbow gradient for the bulb
const BULB_COLORS = [
  '#FFD100',
  '#FFB800',
  '#FF6F61',
  '#C75D00',
  '#009E60',
  '#006400',
  '#58595B',
];

// Gradients per zone (light → dark)
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c'],
};

// Fallback solid colors if a zone isn’t in ZONE_GRADIENTS
const SOLID_COLORS = [
  '#FFD100',
  '#009E60',
  '#FF6F61',
  '#58595B',
  '#FFB800',
  '#C75D00',
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  // Build “semi‐donut” data: each slice gets value=1, count kept for labels
  const pieData = useMemo(() => {
    return summary.map((z) => ({
      name: z.zone,
      value: 1,
      count: z.count,
    }));
  }, [summary]);

  // If no data, placeholder
  if (!summary.length || !pieData.length) {
    return <Card body>No zone data available</Card>;
  }

  // Custom tooltip showing real count
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000',
        }}
      >
        <div>
          <strong>Zone:</strong> {name}
        </div>
        <div style={{ marginTop: 4 }}>
          <strong>Count:</strong> {count}
        </div>
      </div>
    );
  };

  // Helper: build a tiny “rainbow” gradient for the bulb
  // We’ll render multiple overlapping <span> layers, each colored, then mask via SVG.
  // But here, for simplicity, we’ll just pick a cycling color for bulb’s fill.
  // (If you really want a continuous gradient, you can wrap FaLightbulb in an SVG <defs> gradient.)
  const bulbColor = BULB_COLORS[Math.floor(Math.random() * BULB_COLORS.length)];

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      {/* TOP ROW: Lightbulb icon + text */}
      <Card.Header className="bg-dark text-warning d-flex flex-column align-items-center">
        <FaLightbulb style={{ fontSize: '3.5rem', color: bulbColor, opacity: 0.9 }} />
        <div style={{ marginTop: '0.25rem', fontSize: '1.1rem', fontWeight: 600 }}>
          Western Union Pune
        </div>
      </Card.Header>

      <Card.Body style={{ height: 480, padding: 0, position: 'relative' }}>
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem',
            position: 'relative',
            overflowY: 'auto', // allow chart region to scroll if necessary
          }}
        >
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <defs>
                {pieData.map((entry) => {
                  const gradientId = entry.name.replace(/\s+/g, '-');
                  const gradientColors = ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient
                      id={`grad-${gradientId}`}
                      key={`grad-${gradientId}`}
                      x1="0"
                      y1="0"
                      x2="0"
                      y2="1"
                    >
                      <stop offset="0%" stopColor={gradientColors[0]} stopOpacity={1} />
                      <stop offset="100%" stopColor={gradientColors[1]} stopOpacity={1} />
                    </linearGradient>
                  );
                })}
              </defs>

              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                startAngle={180}
                endAngle={0}
                innerRadius={80}
                outerRadius={180}
                paddingAngle={2}
                labelLine={false}
                isAnimationActive={false}
              >
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const gradientId = entry.name.replace(/\s+/g, '-');
                  const hasGradient = Boolean(ZONE_GRADIENTS[entry.name]);
                  const fillColor = hasGradient
                    ? `url(#grad-${gradientId})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  const strokeColor = hasGradient
                    ? ZONE_GRADIENTS[entry.name][1]
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>

              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>
        </div>

        {/* Custom legend at bottom: small colored squares + zone name in that color */}
        <div
          style={{
            position: 'absolute',
            bottom: 0,
            left: 0,
            width: '100%',
            padding: '0.75rem 1rem',
            display: 'flex',
            flexWrap: 'wrap',
            justifyContent: 'center',
            gap: '1.5rem',
            backgroundColor: 'var(--wu-gray-dark)',
          }}
        >
          {summary.map((entry, idx) => {
            const gradientColors = ZONE_GRADIENTS[entry.zone];
            const squareColor = gradientColors
              ? gradientColors[1]
              : SOLID_COLORS[idx % SOLID_COLORS.length];
            return (
              <div
                key={`legend-${idx}`}
                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
              >
                {/* small square “plate” */}
                <div
                  style={{
                    width: '0.9rem',
                    height: '0.9rem',
                    backgroundColor: squareColor,
                    borderRadius: '2px',
                  }}
                />
                <span
                  style={{
                    color: squareColor,
                    fontSize: '0.9rem',
                    fontWeight: 500,
                  }}
                >
                  {entry.zone}
                </span>
              </div>
            );
          })}
        </div>
      </Card.Body>
    </Card>
  );
}












// src/components/SummaryChart.jsx

import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList
} from 'recharts';
import { Card } from 'react-bootstrap';
import { FaLightbulb, FaCircle } from 'react-icons/fa';

// Gradients per zone (light → dark)
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c']
};

// Fallback solid colors if a zone isn’t in ZONE_GRADIENTS
const SOLID_COLORS = [
  '#FFD100',
  '#009E60',
  '#FF6F61',
  '#58595B',
  '#FFB800',
  '#C75D00'
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  // Build pieData: each zone = slice of value=1 (equal angles), but keep real count
  const pieData = useMemo(() => {
    return summary.map((z) => ({
      name:  z.zone,
      value: 1,
      count: z.count
    }));
  }, [summary]);

  // Early return if no data
  if (!summary.length || !pieData.length) {
    return <Card body>No zone data available</Card>;
  }

  // Custom tooltip: shows actual count
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000'
        }}
      >
        <div>
          <strong>Zone:</strong> {name}
        </div>
        <div style={{ marginTop: 4 }}>
          <strong>Count:</strong> {count}
        </div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>
      <Card.Body style={{ height: 500, padding: 0, position: 'relative' }}>
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem',
            position: 'relative'
          }}
        >
          {/* ─── Centered Lightbulb + “Western Union Pune” + Zone-color bar ─── */}
          <div
            style={{
              position:         'absolute',
              top:              '35%',
              left:             '50%',
              transform:        'translate(-50%, -50%)',
              zIndex:           2,
              textAlign:        'center',
              color:            'var(--wu-yellow)',
              pointerEvents:    'none'
            }}
          >
            <FaLightbulb style={{ fontSize: '4rem', opacity: 0.85 }} />
            <div style={{ marginTop: '0.25rem', fontSize: '1.1rem', fontWeight: '600' }}>
              Western Union Pune
            </div>

            {/* ─── Zone-color bar: one small rectangle per zone, using the dark shade ─── */}
            <div
              style={{
                display:      'flex',
                justifyContent:'center',
                gap:           '4px',
                marginTop:     '8px'
              }}
            >
              {summary.map((entry, idx) => {
                // pick the dark shade of gradient if available; otherwise fallback to SOLID_COLORS
                const gradientColors = ZONE_GRADIENTS[entry.zone];
                const color = gradientColors
                  ? gradientColors[1]
                  : SOLID_COLORS[idx % SOLID_COLORS.length];
                return (
                  <div
                    key={`bar-${idx}`}
                    style={{
                      width:  '24px',
                      height: '8px',
                      backgroundColor: color,
                      border: `1px solid #333`,
                      borderRadius: '2px'
                    }}
                    title={`${entry.zone}: ${entry.count}`}
                  />
                );
              })}
            </div>
          </div>

          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <defs>
                {pieData.map((entry) => {
                  const gradientKey = entry.name.replace(/\s+/g, '-');
                  const gradientColors = ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient
                      id={`grad-${gradientKey}`}
                      key={`grad-${gradientKey}`}
                      x1="0"
                      y1="0"
                      x2="0"
                      y2="1"
                    >
                      <stop offset="0%"  stopColor={gradientColors[0]} stopOpacity={1} />
                      <stop offset="100%" stopColor={gradientColors[1]} stopOpacity={1} />
                    </linearGradient>
                  );
                })}
              </defs>

              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                startAngle={180}
                endAngle={0}
                innerRadius={80}
                outerRadius={180}
                paddingAngle={2}
                labelLine={false}
                isAnimationActive={false}
              >
                {/* LabelList shows the real count numerically inside each slice */}
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const gradientKey = entry.name.replace(/\s+/g, '-');
                  const hasGradient = Boolean(ZONE_GRADIENTS[entry.name]);
                  const fillColor = hasGradient
                    ? `url(#grad-${gradientKey})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  const strokeColor = hasGradient
                    ? ZONE_GRADIENTS[entry.name][1]
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>

              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>
        </div>

        {/* ─── Custom Legend at bottom: show a colored dot + zone name in that color ─── */}
        <div
          style={{
            position:      'absolute',
            bottom:        '0',
            left:          0,
            width:         '100%',
            padding:       '0.5rem 1rem',
            display:       'flex',
            flexWrap:      'wrap',
            justifyContent:'center',
            gap:           '1rem',
            backgroundColor:'transparent'
          }}
        >
          {summary.map((entry, idx) => {
            const gradientColors = ZONE_GRADIENTS[entry.zone];
            const dotColor = gradientColors
              ? gradientColors[1]
              : SOLID_COLORS[idx % SOLID_COLORS.length];
            return (
              <div
                key={`legend-${idx}`}
                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
              >
                <FaCircle style={{ color: dotColor, fontSize: '0.9rem' }} />
                <span
                  style={{
                    color:      dotColor,
                    fontSize:   '0.9rem',
                    fontWeight: '500'
                  }}
                >
                  {entry.zone}
                </span>
              </div>
            );
          })}
        </div>
      </Card.Body>
    </Card>
  );
}




















// src/components/SummaryChart.jsx

import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList,
} from 'recharts';
import { Card } from 'react-bootstrap';
import { FaLightbulb, FaCircle } from 'react-icons/fa';

// Gradients per zone (light → dark)
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c'],
};

// If a zone is not in ZONE_GRADIENTS, fall back to one of these
const SOLID_COLORS = [
  '#FFD100',
  '#009E60',
  '#FF6F61',
  '#58595B',
  '#FFB800',
  '#C75D00',
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  // Build data for Pie: each slice has equal “value”=1, but retains the real count
  const pieData = useMemo(() => {
    return summary.map((z) => ({
      name: z.zone,
      value: 1,     // equal-angle slices
      count: z.count,
    }));
  }, [summary]);

  // Early return if no data
  if (!summary.length || !pieData.length) {
    return <Card body>No zone data available</Card>;
  }

  // Custom tooltip shows the actual count for whichever slice is hovered
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000',
        }}
      >
        <div>
          <strong>Zone:</strong> {name}
        </div>
        <div style={{ marginTop: 4 }}>
          <strong>Count:</strong> {count}
        </div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>
      <Card.Body style={{ height: 450, padding: 0, position: 'relative' }}>
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem',
            position: 'relative',
          }}
        >
          {/* Centered • Larger Lightbulb + Text */}
          <div
            style={{
              position: 'absolute',
              top: '40%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              zIndex: 2,
              textAlign: 'center',
              color: 'var(--wu-yellow)',
            }}
          >
            <FaLightbulb style={{ fontSize: '4rem', opacity: 0.85 }} />
            <div style={{ marginTop: '0.25rem', fontSize: '1.1rem', fontWeight: '600' }}>
              Western Union Pune
            </div>
          </div>

          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <defs>
                {pieData.map((entry) => {
                  const gradientId = entry.name.replace(/\s+/g, '-');
                  const gradientColors = ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient
                      id={`grad-${gradientId}`}
                      key={`grad-${gradientId}`}
                      x1="0"
                      y1="0"
                      x2="0"
                      y2="1"
                    >
                      <stop offset="0%" stopColor={gradientColors[0]} stopOpacity={1} />
                      <stop offset="100%" stopColor={gradientColors[1]} stopOpacity={1} />
                    </linearGradient>
                  );
                })}
              </defs>

              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                startAngle={180}
                endAngle={0}
                innerRadius={80}
                outerRadius={180}
                paddingAngle={2}
                labelLine={false}
                isAnimationActive={false}
              >
                {/* Place actual count labels inside each slice */}
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const gradientId = entry.name.replace(/\s+/g, '-');
                  const hasGradient = Boolean(ZONE_GRADIENTS[entry.name]);
                  const fillColor = hasGradient
                    ? `url(#grad-${gradientId})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  const strokeColor = hasGradient
                    ? ZONE_GRADIENTS[entry.name][1]
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>

              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>
        </div>

        {/* Custom legend at bottom: colored dot + zone name in that color */}
        <div
          style={{
            position: 'absolute',
            bottom: 0,
            left: 0,
            width: '100%',
            padding: '0.5rem 1rem',
            display: 'flex',
            flexWrap: 'wrap',
            justifyContent: 'center',
            gap: '1rem',
            backgroundColor: 'transparent',
          }}
        >
          {summary.map((entry, idx) => {
            const gradientColors = ZONE_GRADIENTS[entry.zone];
            const dotColor = gradientColors
              ? gradientColors[1]
              : SOLID_COLORS[idx % SOLID_COLORS.length];
            return (
              <div
                key={`legend-${idx}`}
                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
              >
                <FaCircle style={{ color: dotColor, fontSize: '0.9rem' }} />
                <span
                  style={{
                    color: dotColor,
                    fontSize: '0.9rem',
                    fontWeight: '500',
                  }}
                >
                  {entry.zone}
                </span>
              </div>
            );
          })}
        </div>
      </Card.Body>
    </Card>
  );
}
















// src/components/SummaryChart.jsx

import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList,
} from 'recharts';
import { Card } from 'react-bootstrap';
import { FaLightbulb, FaCircle } from 'react-icons/fa';

// Gradients per zone (light → dark)
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c'],
};

// If a zone doesn’t appear in ZONE_GRADIENTS, pick from this array:
const SOLID_COLORS = [
  '#FFD100',
  '#009E60',
  '#FF6F61',
  '#58595B',
  '#FFB800',
  '#C75D00',
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  // Build pieData at top level (hooks must run unconditionally)
  const pieData = useMemo(() => {
    return summary.map((z) => ({
      name: z.zone,
      value: 1,     // Each slice equal-angle
      count: z.count,
    }));
  }, [summary]);

  // If there’s no data or pieData is empty, show a fallback
  if (!summary.length || !pieData.length) {
    return <Card body>No zone data available</Card>;
  }

  // Custom tooltip to display actual count
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000',
        }}
      >
        <div>
          <strong>Zone:</strong> {name}
        </div>
        <div style={{ marginTop: 4 }}>
          <strong>Count:</strong> {count}
        </div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>
      <Card.Body style={{ height: 450, padding: 0, position: 'relative' }}>
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem',
            position: 'relative',
          }}
        >
          {/* Centered lightbulb icon */}
          <div
            style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              zIndex: 2,
              color: 'var(--wu-yellow)',
              fontSize: '2.5rem',
              opacity: 0.8,
            }}
          >
            <FaLightbulb />
          </div>

          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <defs>
                {pieData.map((entry) => {
                  const gradientId = entry.name.replace(/\s+/g, '-');
                  const gradientColors =
                    ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient
                      id={`grad-${gradientId}`}
                      key={`grad-${gradientId}`}
                      x1="0"
                      y1="0"
                      x2="0"
                      y2="1"
                    >
                      <stop offset="0%" stopColor={gradientColors[0]} stopOpacity={1} />
                      <stop offset="100%" stopColor={gradientColors[1]} stopOpacity={1} />
                    </linearGradient>
                  );
                })}
              </defs>

              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                startAngle={180}   // create a half-donut
                endAngle={0}
                innerRadius={80}
                outerRadius={180}
                paddingAngle={2}
                labelLine={false}
                isAnimationActive={false}
              >
                {/* Show the actual count inside each slice */}
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const gradientId = entry.name.replace(/\s+/g, '-');
                  const hasGradient = Boolean(ZONE_GRADIENTS[entry.name]);
                  const fillColor = hasGradient
                    ? `url(#grad-${gradientId})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  const strokeColor = hasGradient
                    ? ZONE_GRADIENTS[entry.name][1]
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>
              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>
        </div>

        {/* Custom legend at bottom */}
        <div
          style={{
            position: 'absolute',
            bottom: 0,
            left: 0,
            width: '100%',
            backgroundColor: 'transparent',
            padding: '0.5rem 1rem',
            display: 'flex',
            flexWrap: 'wrap',
            justifyContent: 'center',
            gap: '1rem',
          }}
        >
          {summary.map((entry, idx) => {
            const gradientId = entry.zone.replace(/\s+/g, '-');
            const hasGradient = Boolean(ZONE_GRADIENTS[entry.zone]);
            const dotColor = hasGradient
              ? ZONE_GRADIENTS[entry.zone][1]
              : SOLID_COLORS[idx % SOLID_COLORS.length];
            return (
              <div
                key={`legend-${idx}`}
                style={{ display: 'flex', alignItems: 'center', gap: '0.35rem' }}
              >
                <FaCircle style={{ color: dotColor, fontSize: '0.75rem' }} />
                <span style={{ color: '#fff', fontSize: '0.9rem', fontWeight: '500' }}>
                  {entry.zone} ({entry.count})
                </span>
              </div>
            );
          })}
        </div>
      </Card.Body>
    </Card>
  );
}














// src/components/SummaryChart.jsx
import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList,
} from 'recharts';
import { Card } from 'react-bootstrap';
import { FaLightbulb, FaCircle } from 'react-icons/fa';

// Gradients per zone (light → dark)
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c'],
};

const SOLID_COLORS = [
  '#FFD100', // fallback if a zone isn't in ZONE_GRADIENTS
  '#009E60',
  '#FF6F61',
  '#58595B',
  '#FFB800',
  '#C75D00',
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  // If there's no data, show a simple placeholder:
  if (!summary.length) {
    return <Card body>No zone data available</Card>;
  }

  // Build `pieData` where each slice has value 1 (equal angle)
  // but carry `count` separately for labeling/tooltip.
  const pieData = useMemo(
    () =>
      summary.map((z) => ({
        name: z.zone,
        value: 1,
        count: z.count,
      })),
    [summary]
  );

  // Render a custom tooltip showing actual "count"
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000',
        }}
      >
        <div>
          <strong>Zone:</strong> {name}
        </div>
        <div style={{ marginTop: 4 }}>
          <strong>Count:</strong> {count}
        </div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>
      <Card.Body style={{ height: 450, padding: 0, position: 'relative' }}>
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem',
            position: 'relative',
          }}
        >
          {/* Lightbulb in the very center */}
          <div
            style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              zIndex: 2,
              color: 'var(--wu-yellow)',
              fontSize: '2.5rem',
              opacity: 0.8,
            }}
          >
            <FaLightbulb />
          </div>

          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              {/* Define gradients for each zone */}
              <defs>
                {pieData.map((entry) => {
                  const gradientKey = entry.name.replace(/\s+/g, '-');
                  const gradientColors =
                    ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient
                      id={`grad-${gradientKey}`}
                      key={gradientKey}
                      x1="0"
                      y1="0"
                      x2="0"
                      y2="1"
                    >
                      <stop offset="0%" stopColor={gradientColors[0]} stopOpacity={1} />
                      <stop offset="100%" stopColor={gradientColors[1]} stopOpacity={1} />
                    </linearGradient>
                  );
                })}
              </defs>

              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                startAngle={180}  // start at left
                endAngle={0}      // end at right → semi-circle
                innerRadius={80}  // thickness of donut (adjust to taste)
                outerRadius={180}
                paddingAngle={2}
                labelLine={false}
                isAnimationActive={false}
              >
                {/* LabelList to show actual `count` at centroid of each slice */}
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const gradientKey = entry.name.replace(/\s+/g, '-');
                  const hasGradient = Boolean(ZONE_GRADIENTS[entry.name]);
                  const fillColor = hasGradient
                    ? `url(#grad-${gradientKey})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  const strokeColor = hasGradient
                    ? ZONE_GRADIENTS[entry.name][1]
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>
              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>
        </div>

        {/* Custom Legend below the chart */}
        <div
          style={{
            position: 'absolute',
            bottom: 0,
            left: 0,
            width: '100%',
            backgroundColor: 'transparent',
            padding: '0.5rem 1rem',
            display: 'flex',
            flexWrap: 'wrap',
            justifyContent: 'center',
            gap: '1rem',
          }}
        >
          {summary.map((entry, idx) => {
            const gradientKey = entry.zone.replace(/\s+/g, '-');
            const hasGradient = Boolean(ZONE_GRADIENTS[entry.zone]);
            const color = hasGradient
              ? ZONE_GRADIENTS[entry.zone][1]
              : SOLID_COLORS[idx % SOLID_COLORS.length];
            return (
              <div
                key={`legend-${idx}`}
                style={{ display: 'flex', alignItems: 'center', gap: '0.35rem' }}
              >
                <FaCircle style={{ color, fontSize: '0.75rem' }} />
                <span style={{ color: '#fff', fontSize: '0.9rem', fontWeight: '500' }}>
                  {entry.zone} ({entry.count})
                </span>
              </div>
            );
          })}
        </div>
      </Card.Body>
    </Card>
  );
}














// src/components/SummaryChart.jsx

import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList,
} from 'recharts';
import { Card } from 'react-bootstrap';

// Gradients or solid colors per zone
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c'],
};

// Fallback solid colors if needed
const SOLID_COLORS = [
  '#FFD100',
  '#009E60',
  '#FF6F61',
  '#58595B',
  '#FFB800',
  '#C75D00',
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  // Build pie data with fixed "value:1" so each slice is equal in angle,
  // but carry the real "count" to show on tooltip / label.
  const pieData = useMemo(
    () =>
      summary.map((z) => ({
        name:  z.zone,
        value: 1,
        count: z.count,
      })),
    [summary]
  );

  // If no data, return placeholder
  if (!summary.length) {
    return <Card body>No zone data available</Card>;
  }

  // Custom tooltip that shows real count
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000',
        }}
      >
        <div><strong>Zone:</strong> {name}</div>
        <div style={{ marginTop: 4 }}><strong>Count:</strong> {count}</div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>

      {/* Bump up the Card Body height so the chart has room */}
      <Card.Body style={{ height: 500, padding: 0 }}>
        <div
          style={{
            position: 'relative',
            width: '100%',
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem',
          }}
        >
          {/* This container will fill the above div */}
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <defs>
                {pieData.map((entry) => {
                  const key = entry.name.replace(/\s+/g, '-');
                  const colors = ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient id={`grad-${key}`} key={key} x1="0" y1="0" x2="0" y2="1">
                      <stop offset="0%" stopColor={colors[0]} stopOpacity={1} />
                      <stop offset="100%" stopColor={colors[1]} stopOpacity={1} />
                    </linearGradient>
                  );
                })}
              </defs>

              {/* 
                startAngle=180, endAngle=0 → draws a horizontal semi‐circle (left to right).
                Increased radii to occupy more of the 500px height. 
              */}
              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                startAngle={180}
                endAngle={0}
                innerRadius={80}
                outerRadius={180}
                paddingAngle={2}
                labelLine={false}
                isAnimationActive={false}
              >
                {/* 
                  Place the actual "count" in the center of each slice 
                  (white text).
                */}
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const key = entry.name.replace(/\s+/g, '-');
                  const hasGradient = Boolean(ZONE_GRADIENTS[entry.name]);
                  const fillColor = hasGradient
                    ? `url(#grad-${key})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  const strokeColor = hasGradient
                    ? ZONE_GRADIENTS[entry.name][1]
                    : SOLID_COLORS[idx % SOLID_COLORS.length];

                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>

              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>

          {/* 
            OPTIONAL: center‐overlay “bulb” image. 
            Replace '/path/to/bulb.svg' with your actual asset path. 
            You can also adjust width/height as needed. 
          */}
          <div
            style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              pointerEvents: 'none',
            }}
          >
            <img
              src="/path/to/bulb.svg"
              alt="Center Bulb"
              style={{ width: 100, height: 100, opacity: 0.8 }}
            />
          </div>
        </div>
      </Card.Body>
    </Card>
  );
}










// src/components/SummaryChart.jsx
import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList,
} from 'recharts';
import { Card } from 'react-bootstrap';

// Gradients or solid colors per zone
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c'],
};

const SOLID_COLORS = [
  '#FFD100', // fallback
  '#009E60',
  '#FF6F61',
  '#58595B',
  '#FFB800',
  '#C75D00',
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  // Build memoized pie data even if empty; hook must not be conditional
  const pieData = useMemo(
    () =>
      summary.map((z) => ({
        name: z.zone,
        value: 1,       // fixed value for equal slice angles
        count: z.count, // actual occupancy count
      })),
    [summary]
  );

  // Early return if no data
  if (!summary.length) {
    return <Card body>No zone data available</Card>;
  }

  // Tooltip content
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload?.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000',
        }}
      >
        <div><strong>Zone:</strong> {name}</div>
        <div style={{ marginTop: 4 }}><strong>Count:</strong> {count}</div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>
      <Card.Body style={{ height: 400, padding: 0 }}>
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem',
          }}
        >
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <defs>
                {pieData.map((entry) => {
                  const gradientKey = entry.name.replace(/\s+/g, '-');
                  const gradientColors = ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient
                      id={`grad-${gradientKey}`}
                      key={gradientKey}
                      x1="0"
                      y1="0"
                      x2="0"
                      y2="1"
                    >
                      <stop offset="0%" stopColor={gradientColors[0]} stopOpacity={1} />
                      <stop offset="100%" stopColor={gradientColors[1]} stopOpacity={1} />
                    </linearGradient>
                  );
                })}
              </defs>

              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                startAngle={180}
                endAngle={0}
                innerRadius={60}
                outerRadius={140}
                paddingAngle={2}
                labelLine={false}
                isAnimationActive={false}
              >
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const gradientKey = entry.name.replace(/\s+/g, '-');
                  const hasGradient = Boolean(ZONE_GRADIENTS[entry.name]);
                  const fillColor = hasGradient
                    ? `url(#grad-${gradientKey})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  const strokeColor = hasGradient
                    ? ZONE_GRADIENTS[entry.name][1]
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>

              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </Card.Body>
    </Card>
  );
}













// src/components/SummaryChart.jsx
import React, { useMemo } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  LabelList,
} from 'recharts';
import { Card } from 'react-bootstrap';

// Gradients or solid colors per zone (you can swap these for solid fills if desired)
const ZONE_GRADIENTS = {
  'Red Zone':       ['#A80000', '#FFCCCC'],
  'Yellow Zone':    ['#B28000', '#FFF2CC'],
  'Orange Zone':    ['#C75D00', '#FFE0B2'],
  'Green Zone':     ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':        ['#bfd6ff', '#002f6c'],
};

// If you prefer a solid color per slice (instead of gradient), list them here in order:
const SOLID_COLORS = [
  '#FFD100', // fallback / accent if a zone isn’t in ZONE_GRADIENTS
  '#009E60',
  '#FF6F61',
  '#58595B',
  '#FFB800',
  '#C75D00',
];

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  // summary is an array of objects: [ { zone: 'Red Zone', count: 10 }, ... ]
  // We want each slice to have equal angle in the half circle, but still carry the true count.

  // If there’s no data, show a placeholder card:
  if (!summary.length) {
    return <Card body>No zone data available</Card>;
  }

  // Build a new data array where each slice has a fixed 'value' of 1, so angles are equal.
  // We attach the real count in a separate field.
  const pieData = useMemo(
    () =>
      summary.map((z) => ({
        name: z.zone,
        value: 1,
        count: z.count,
      })),
    [summary]
  );

  // Custom tooltip to show real count when hovering
  const renderTooltip = ({ active, payload }) => {
    if (!active || !payload || !payload.length) return null;
    const { name, count } = payload[0].payload;
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          borderRadius: 4,
          padding: '8px',
          color: '#000',
        }}
      >
        <div>
          <strong>Zone:</strong> {name}
        </div>
        <div style={{ marginTop: 4 }}>
          <strong>Count:</strong> {count}
        </div>
      </div>
    );
  };

  // We’ll draw the Pie with a “startAngle” at 180° and “endAngle” at 0°,
  // so it spans a half-circle (a “semi-donut”). Each slice is therefore equal in width.
  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: 'var(--wu-yellow)' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>
      <Card.Body style={{ height: 400, padding: 0 }}>
        <div
          style={{
            height: '100%',
            backgroundColor: 'var(--wu-gray-dark)',
            border: '1px solid var(--wu-yellow)',
            borderRadius: 4,
            padding: '0.5rem',
          }}
        >
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              {/* Define gradients for each zone (by mapping index → gradient ID) */}
              <defs>
                {pieData.map((entry, idx) => {
                  // pick the gradient for this zone, fallback if missing:
                  const gradientKey = entry.name.replace(/\s+/g, '-');
                  const gradientColors =
                    ZONE_GRADIENTS[entry.name] || DEFAULT_GRADIENT;
                  return (
                    <linearGradient
                      id={`grad-${gradientKey}`}
                      key={gradientKey}
                      x1="0"
                      y1="0"
                      x2="0"
                      y2="1"
                    >
                      <stop offset="0%" stopColor={gradientColors[0]} stopOpacity={1} />
                      <stop
                        offset="100%"
                        stopColor={gradientColors[1]}
                        stopOpacity={1}
                      />
                    </linearGradient>
                  );
                })}
              </defs>

              <Pie
                data={pieData}
                dataKey="value"        // all slices equal
                nameKey="name"
                startAngle={180}      // leftmost is 180°, end at 0° for a half circle
                endAngle={0}
                innerRadius={60}      // thickness of arc
                outerRadius={140}
                paddingAngle={2}      // small gap between slices
                labelLine={false}
                isAnimationActive={false}
              >
                {/* Place a LabelList that prints the real count (entry.count) at centroid of each slice */}
                <LabelList
                  dataKey="count"
                  position="inside"
                  fill="#fff"
                  style={{ fontSize: '1rem', fontWeight: 'bold' }}
                />
                {pieData.map((entry, idx) => {
                  const gradientKey = entry.name.replace(/\s+/g, '-');
                  const hasGradient = Boolean(ZONE_GRADIENTS[entry.name]);
                  // Fallback to a solid color if no gradient is defined
                  const fillColor = hasGradient
                    ? `url(#grad-${gradientKey})`
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  // Stroke color can be the darker shade of that gradient, or fallback
                  const strokeColor = hasGradient
                    ? ZONE_GRADIENTS[entry.name][1]
                    : SOLID_COLORS[idx % SOLID_COLORS.length];
                  return (
                    <Cell
                      key={`slice-${idx}`}
                      fill={fillColor}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Pie>

              <Tooltip content={renderTooltip} />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </Card.Body>
    </Card>
  );
}












I want to Reoresent this chart data into above image format

// src/components/SummaryChart.jsx

import React, { useEffect } from 'react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  CartesianGrid,
  ResponsiveContainer,
  Legend,
  Cell
} from 'recharts';
import { Card } from 'react-bootstrap';

// Zone gradients
const ZONE_GRADIENTS = {
  'Red Zone': ['#A80000', '#FFCCCC'],
  'Yellow Zone': ['#B28000', '#FFF2CC'],
  'Orange Zone': ['#C75D00', '#FFE0B2'],
  'Green Zone': ['#006400', '#CCFFCC'],
  'Reception Area': ['#4B0082', '#E0CCFF'],
  'Tower B':['#bfd6ff', '#002f6c'],
};

const ZONE_LABEL_COLORS = {
  'Red Zone': '#A80000',
  'Yellow Zone': '#B28000',
  'Orange Zone': '#C75D00',
  'Green Zone': '#006400',
  'Reception Area': '#4B0082',
};

const DEFAULT_GRADIENT = ['#3B4CCA', '#D0D8FF'];

export default function SummaryChart({ summary = [] }) {
  useEffect(() => {
    console.log('Summary Chart Data:', summary);
  }, [summary]);

  if (!summary.length) return <Card body>No zone data available</Card>;

  const renderLabel = ({ x, y, width, value, index }) => {
    const zone = summary[index].zone;
    const color = ZONE_LABEL_COLORS[zone] || '#333';
    return (
      <text
        x={x + width / 2}
        y={y - 6}
        fill={color}
        textAnchor="middle"
        fontSize={12}
        fontWeight="bold"
      >
        {value}
      </text>
    );
  };

  const renderTooltip = ({ active, payload, label }) => {
    if (!active || !payload?.length) return null;
    const { zone, count } = payload[0].payload;
    const color = ZONE_LABEL_COLORS[zone] || '#333';
    return (
      <div
        style={{
          backgroundColor: '#fff',
          border: '1px solid #ccc',
          padding: '8px',
          borderRadius: '4px',
          color: '#000'
        }}
      >
        <div><strong>{label}</strong></div>
        <div style={{ color }}>
          {payload[0].name}: {count}
        </div>
      </div>
    );
  };

  return (
    <Card className="mb-4 shadow-sm border" style={{ borderColor: '#e0e0e0' }}>
      <Card.Header className="bg-dark text-warning text-center">
        Zone-wise Occupancy
      </Card.Header>
      <Card.Body style={{ height: 400, padding: 0 }}>
        {/* <div
          style={{
            height: '100%',
            border: '1px solid #ccc',
            borderRadius: '4px',
            backgroundColor: '#ffffff'
          }}
        > */}

        <div
          style={{
            height: '100%',
            border: '1px solid var(--wu-yellow)',
            borderRadius: '4px',
            backgroundColor: 'var(--wu-gray-dark)',
            padding: '0.5rem'
          }}
        >

          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={summary}
              margin={{ top: 20, right: 30, left: 0, bottom: 5 }}
              barCategoryGap="10%"
            >
              {/* Unique gradient defs by zone name */}
              <defs>
                {Object.entries(ZONE_GRADIENTS).map(([zone, [start, end]]) => (
                  <linearGradient
                    id={`grad-${zone.replace(/\s+/g, '-')}`}
                    key={zone}
                    x1="0"
                    y1="0"
                    x2="0"
                    y2="1"
                  >
                    <stop offset="0%" stopColor={start} stopOpacity={1} />
                    <stop offset="100%" stopColor={end} stopOpacity={1} />
                  </linearGradient>
                ))}
              </defs>

              {/* <CartesianGrid stroke="#d0d0d0" strokeDasharray="4 4" />
              <XAxis dataKey="zone" tick={{ fontSize: 12, fill: '#333' }} />
              <YAxis allowDecimals={false} tick={{ fontSize: 12, fill: '#333' }} /> */}

              <CartesianGrid stroke="#555" strokeDasharray="4 4" />
              <XAxis dataKey="zone" tick={{ fontSize: 12, fill: '#fff' }} />
              <YAxis allowDecimals={false} tick={{ fontSize: 12, fill: '#fff' }} />


              <Tooltip content={renderTooltip} />

              <Legend
                verticalAlign="bottom"
                wrapperStyle={{ paddingTop: 10 }}
                formatter={(value) => (
                  <span style={{ color: '#FFD100', fontWeight: 'bold' }}>
                    {value}
                  </span>
                )}
              />

              <Bar
                dataKey="count"
                name="Zone"
                radius={[6, 6, 0, 0]}
                label={renderLabel}
              >
                {summary.map((entry, idx) => {
                  const zone = entry.zone;
                  const gradientId = `grad-${zone.replace(/\s+/g, '-')}`;
                  const strokeColor = ZONE_LABEL_COLORS[zone] || '#333';
                  const gradientExists = ZONE_GRADIENTS.hasOwnProperty(zone);

                  return (
                    <Cell
                      key={`cell-${idx}`}
                      fill={gradientExists ? `url(#${gradientId})` : DEFAULT_GRADIENT[0]}
                      stroke={strokeColor}
                      strokeWidth={1}
                    />
                  );
                })}
              </Bar>
            </BarChart>
          </ResponsiveContainer>
        </div>
      </Card.Body>
    </Card>
  );
}

