const fs = require('fs');
const path = require('path');
const xlsx = require('xlsx');

const inputFilePath = path.join(__dirname, '../data/punedoor.xlsx');
const outputFilePath = path.join(__dirname, '../data/zoneFloorMap.js');

const workbook = xlsx.readFile(inputFilePath);
const sheetName = workbook.SheetNames[0];
const sheet = workbook.Sheets[sheetName];
const data = xlsx.utils.sheet_to_json(sheet);

const zoneSet = new Set();

data.forEach((row, index) => {
  const inZone  = row['IN Direction Zone Name']?.trim();
  const outZone = row['OUT Direction Zone Name']?.trim();

  if (inZone) zoneSet.add(inZone);
  if (outZone) zoneSet.add(outZone);
});

const zoneMap = {};
[...zoneSet].forEach(zone => {
  zoneMap[zone] = 'Unknown Floor'; // Default floor
});

const fileContent = `// Auto-generated from punedoor.xlsx

const zoneFloorMap = ${JSON.stringify(zoneMap, null, 2)};

module.exports = zoneFloorMap;
`;

fs.writeFileSync(outputFilePath, fileContent, 'utf8');
console.log(`✅ zoneFloorMap.js generated with ${zoneSet.size} zone entries.`);












node scripts/generateDoorZoneMap.js


const fs = require('fs');
const path = require('path');
const xlsx = require('xlsx');

// Paths
const inputFilePath = path.join(__dirname, '../data/punedoor.xlsx');
const outputFilePath = path.join(__dirname, '../data/doorZoneMap.js');

// Read workbook
const workbook = xlsx.readFile(inputFilePath);
const sheet = workbook.Sheets[workbook.SheetNames[0]];
const data = xlsx.utils.sheet_to_json(sheet);

const map = {};

data.forEach((row, index) => {
  const door = row['Door Name']?.trim();
  const inZone = row['IN Zone']?.trim();
  const outZone = row['OUT Zone']?.trim();

  if (!door) {
    console.warn(`Skipping row ${index + 2}: Missing door name`);
    return;
  }

  if (inZone) {
    map[`${door}___InDirection`] = inZone;
  }

  if (outZone) {
    map[`${door}___OutDirection`] = outZone;
  }
});

const fileContent = `// Auto-generated from punedoor.xlsx

function mapDoorToZone(door, direction) {
  const key = \`\${door}___\${direction}\`;
  return doorZoneMap[key];
}

const doorZoneMap = ${JSON.stringify(map, null, 2)};

module.exports = mapDoorToZone;
`;

fs.writeFileSync(outputFilePath, fileContent, 'utf8');
console.log(`✅ doorZoneMap.js generated with ${Object.keys(map).length} entries.`);










const { poolConnect, pool, sql } = require('../config/db');
const doorZoneMap  = require('../data/doorZoneMap'); // renamed from mapDoorToZone to doorZoneMap
const zoneFloorMap = require('../data/zoneFloorMap');

// Add this helper function to map door + direction to zone
function mapDoorToZone(doorName, direction) {
  return doorZoneMap[`${doorName}___${direction}`] || 'Unknown Zone';
}

async function fetchNewEvents(since) {
  const req = pool.request();
  req.input('since', sql.DateTime2, since);
  const result = await req.query(`
    WITH CombinedQuery AS (
      SELECT 
        DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE 
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          SCard.[value]
        ) AS CardNumber,
        t5_admit.value AS AdmitCode,
        t5_dir.value   AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]      t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType]  t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_admit
        ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_dir
        ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, [value]
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE [Name] IN ('Card','CHUID')
      ) AS SCard
        ON t1.XmlGUID = SCard.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return result.recordset;
}

async function fetchTotalVisitedToday() {
  const req = pool.request();
  const todayStart = new Date();
  todayStart.setHours(0, 0, 0, 0);
  req.input('start', sql.DateTime2, todayStart);

  const result = await req.query(`
    WITH DailyVisits AS (
      SELECT DISTINCT
        CASE 
          WHEN pt.Name IN ('Contractor','Terminated Contractor') THEN p.Text12
          ELSE CAST(p.Int1 AS NVARCHAR)
        END AS EmployeeID
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] log
      LEFT JOIN [ACVSCore].[Access].[Personnel] p ON log.ObjectIdentity1 = p.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] pt ON p.PersonnelTypeId = pt.ObjectID
      WHERE 
        log.MessageType = 'CardAdmitted'
        AND log.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * log.MessageLocaleOffset, log.MessageUTC) >= @start
    )
    SELECT COUNT(*) AS totalVisitedToday FROM DailyVisits;
  `);

  return result.recordset[0]?.totalVisitedToday || 0;
}

async function buildOccupancy(allEvents) {
  const current      = {};
  const uniquePeople = new Map();

  for (const evt of allEvents) {
    const {
      EmployeeID, ObjectName1, PersonnelType,
      CardNumber, Dateonly, Swipe_Time,
      Direction, Door
    } = evt;

    const zone = mapDoorToZone(Door, Direction) || 'Unknown Zone';

    const dedupKey = EmployeeID || CardNumber || ObjectName1;

    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, { PersonnelType });
      current[EmployeeID] = {
        Dateonly, Swipe_Time, EmployeeID, ObjectName1,
        CardNumber, PersonnelType, zone
      };
    } else {
      uniquePeople.delete(dedupKey);
      delete current[EmployeeID];
    }
  }

  let employeeCount    = 0;
  let contractorCount  = 0;

  for (const { PersonnelType } of uniquePeople.values()) {
    if (PersonnelType === 'Employee' || PersonnelType === 'Terminated Personnel') {
      employeeCount++;
    } else {
      contractorCount++;
    }
  }

  const zoneMap = {};
  Object.values(current).forEach(emp => {
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  });

  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const byType = emps.reduce((acc, { PersonnelType }) => {
        acc[PersonnelType] = (acc[PersonnelType] || 0) + 1;
        return acc;
      }, {});
      return [zone, { total: emps.length, byPersonnelType: byType, employees: emps }];
    })
  );

  const floorMap = {};
  for (const [zone, d] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += d.total;
    for (const [pt, c] of Object.entries(d.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt] || 0) + c;
    }
  }

  const summary        = Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, count: d.total }));
  const zoneBreakdown  = Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, ...d.byPersonnelType, total: d.total }));
  const floorBreakdown = Object.entries(floorMap).map(([f, d]) => ({ floor: f, ...d.byPersonnelType, total: d.total }));

  const personnelBreakdown = [];
  if (employeeCount > 0) {
    personnelBreakdown.push({ personnelType: 'Employee', count: employeeCount });
  }
  if (contractorCount > 0) {
    personnelBreakdown.push({ personnelType: 'Contractor', count: contractorCount });
  }

  return {
    asOf: new Date().toISOString(),
    summary,
    zoneBreakdown,
    floorBreakdown,
    details: zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
    personnelBreakdown,
  };
}

exports.getLiveOccupancy = async (req, res) => {
  try {
    await poolConnect;

    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection':   'keep-alive'
    });
    res.write('\n');

    let lastSeen  = new Date(Date.now() - 1000 * 60 * 60);
    const events  = [];

    const push = async () => {
      const fresh = await fetchNewEvents(lastSeen);
      if (fresh.length) {
        lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
        events.push(...fresh);
        const payload = await buildOccupancy(events);
        payload.totalVisitedToday = await fetchTotalVisitedToday();
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
      }
    };

    {
      const recent = await fetchNewEvents(lastSeen);
      if (recent.length) {
        lastSeen = recent[recent.length - 1].LocaleMessageTime;
        events.push(...recent);
      }
      const initial = await buildOccupancy(events);
      initial.totalVisitedToday = await fetchTotalVisitedToday();
      res.write(`data: ${JSON.stringify(initial)}\n\n`);
    }

    const timer = setInterval(push, 1000);
    req.on('close', () => clearInterval(timer));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};











Lets read liveOccupaccyController.js file carefully and solve above issue and give me updated js file carefully.
dont make another changes in this file 


const { poolConnect, pool, sql } = require('../config/db');
const mapDoorToZone   = require('../data/doorZoneMap');
const zoneFloorMap    = require('../data/zoneFloorMap');

async function fetchNewEvents(since) {
  const req = pool.request();
  req.input('since', sql.DateTime2, since);
  const result = await req.query(`
    WITH CombinedQuery AS (
      SELECT 
        DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE 
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          SCard.[value]
        ) AS CardNumber,
        t5_admit.value AS AdmitCode,
        t5_dir.value   AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]      t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType]  t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_admit
        ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_dir
        ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, [value]
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE [Name] IN ('Card','CHUID')
      ) AS SCard
        ON t1.XmlGUID = SCard.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return result.recordset;
}

// New function to count total employees who visited today
async function fetchTotalVisitedToday() {
  const req = pool.request();
  const todayStart = new Date();
  todayStart.setHours(0, 0, 0, 0);
  req.input('start', sql.DateTime2, todayStart);

  const result = await req.query(`
    WITH DailyVisits AS (
      SELECT DISTINCT
        CASE 
          WHEN pt.Name IN ('Contractor','Terminated Contractor') THEN p.Text12
          ELSE CAST(p.Int1 AS NVARCHAR)
        END AS EmployeeID
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] log
      LEFT JOIN [ACVSCore].[Access].[Personnel] p ON log.ObjectIdentity1 = p.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] pt ON p.PersonnelTypeId = pt.ObjectID
      WHERE 
        log.MessageType = 'CardAdmitted'
        AND log.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * log.MessageLocaleOffset, log.MessageUTC) >= @start
    )
    SELECT COUNT(*) AS totalVisitedToday FROM DailyVisits;
  `);

  return result.recordset[0]?.totalVisitedToday || 0;
}

async function buildOccupancy(allEvents) {

  const current      = {};              // keyed by EmployeeID
  const uniquePeople = new Map();       // dedup key → person record

  for (const evt of allEvents) {
    const {
      EmployeeID, ObjectName1, PersonnelType,
      CardNumber, Dateonly, Swipe_Time,
      Direction, Door
    } = evt;

    const zone = mapDoorToZone(Door, Direction) || 'Unknown Zone';
    

    // build a stable dedup key: EmployeeID → CardNumber → Name
    const dedupKey = EmployeeID || CardNumber || ObjectName1;

    if (Direction === 'InDirection') {
      // add / update
      uniquePeople.set(dedupKey, { PersonnelType });
      current[EmployeeID] = {
        Dateonly, Swipe_Time, EmployeeID, ObjectName1,
        CardNumber, PersonnelType, zone
      };
    } else {
      // remove
      uniquePeople.delete(dedupKey);
      delete current[EmployeeID];
    }
  }

  /* ---- employee vs contractor live counts (summary cards) ---- */
  let employeeCount    = 0;
  let contractorCount  = 0;

  for (const { PersonnelType } of uniquePeople.values()) {
    if (PersonnelType === 'Employee' || PersonnelType === 'Terminated Personnel') {
      employeeCount++;
    } else {
      contractorCount++;
    }
  }

  /* ------------ existing zone / floor aggregations ------------- */
  const zoneMap = {};
  Object.values(current).forEach(emp => {
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  });

  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const byType = emps.reduce((acc, { PersonnelType }) => {
        acc[PersonnelType] = (acc[PersonnelType] || 0) + 1;
        return acc;
      }, {});
      return [zone, { total: emps.length, byPersonnelType: byType, employees: emps }];
    })
  );

  const floorMap = {};
  for (const [zone, d] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += d.total;
    for (const [pt, c] of Object.entries(d.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt] || 0) + c;
    }
  }

  const summary        = Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, count: d.total }));
  const zoneBreakdown  = Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, ...d.byPersonnelType, total: d.total }));
  const floorBreakdown = Object.entries(floorMap).map(([f, d]) => ({ floor: f, ...d.byPersonnelType, total: d.total }));


 const personnelBreakdown = [];

if (employeeCount > 0) {
  personnelBreakdown.push({ personnelType: 'Employee', count: employeeCount });
}
if (contractorCount > 0) {
  personnelBreakdown.push({ personnelType: 'Contractor', count: contractorCount });
}





  return {
    asOf: new Date().toISOString(),
    summary,
    zoneBreakdown,
    floorBreakdown,
    details: zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount }, // NEW
      personnelBreakdown,
  
  };
}


/* --------------------- SSE controller ------------------------ */
exports.getLiveOccupancy = async (req, res) => {
  try {
    await poolConnect;

    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection':   'keep-alive'
    });
    res.write('\n');

    let lastSeen  = new Date(Date.now() - 1000 * 60 * 60); // 1 h ago
    const events  = [];

    /* helper to push updates */
    const push = async () => {
      const fresh = await fetchNewEvents(lastSeen);
      if (fresh.length) {
        lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
        events.push(...fresh);
        const payload = await buildOccupancy(events);
        payload.totalVisitedToday = await fetchTotalVisitedToday(); // <-- ADD THIS LINE
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
      }
    };

    /* initial payload */
    {
      const recent = await fetchNewEvents(lastSeen);
      if (recent.length) {
        lastSeen = recent[recent.length - 1].LocaleMessageTime;
        events.push(...recent);
      }
      const initial = await buildOccupancy(events);
      initial.totalVisitedToday = await fetchTotalVisitedToday(); // <-- ADD THIS LINE
      res.write(`data: ${JSON.stringify(initial)}\n\n`);
    }

    const timer = setInterval(push, 1000);
    req.on('close', () => clearInterval(timer));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};
