// controllers/denverLiveOccupancyController.js

const { DateTime }       = require('luxon');
const { denver }         = require('../config/siteConfig');
const doorFloorMap       = require('../data/denverDoorFloorMap');
const { monitoredDoors } = require('../data/strictDoorList');
const sql                = require('mssql');
const normalizeKey       = require('../data/normalizeKey');

const warnedKeys = new Set();
const normalizedMonitoredKeys = new Set(
  Object.entries(monitoredDoors).map(([door, dir]) =>
    normalizeKey(door, dir)
  )
);

function mapDoorToFloor(rawDoor, rawDir) {
  const key = normalizeKey(rawDoor, rawDir);
  if (doorFloorMap[key]) return doorFloorMap[key];
  const m = rawDoor.match(/HQ\.\s*(\d{1,2})\b/);
  if (m) return `Floor ${m[1]}`;
  if (!warnedKeys.has(key)) {
    console.warn(`⛔ Unmapped door-floor key: "${key}"`);
    warnedKeys.add(key);
  }
  return 'Unknown Floor';
}

function isTodayInDenver(dateOnly) {
  const swipeDate = DateTime.fromISO(dateOnly, { zone: 'America/Denver' })
    .toFormat('yyyy-LL-dd');
  const today     = DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
  return swipeDate === today;
}

async function fetchNewEvents(since) {
  const pool = await denver.pool.connect();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);
  const { recordset } = await req.query(`
    /* … your same SQL … */
  `);
  return recordset;
}

function computeTotalVisitedToday(allEvents) {
  const seen = new Set();
  allEvents.forEach(evt => {
    if (evt.Direction === 'InDirection' && isTodayInDenver(evt.Dateonly)) {
      seen.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    }
  });
  return seen.size;
}

function buildOccupancyForToday(allEvents, freshEvents) {
  // ─── A) Evict “Out of office” ───────────────────────────────────
  const lastByPerson = new Map();
  allEvents.forEach(evt => {
    if (!isTodayInDenver(evt.Dateonly)) return;
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    const prev = lastByPerson.get(key);
    if (!prev || evt.LocaleMessageTime > prev.LocaleMessageTime) {
      lastByPerson.set(key, evt);
    }
  });
  const evicted = new Set();
  lastByPerson.forEach(evt => {
    if (
      evt.Direction === 'OutDirection' &&
      mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office'
    ) {
      evicted.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    }
  });

  // ─── 1) Dedupe live InDirection by last swipe ──────────────────
  const liveMap = new Map();
  allEvents.forEach(evt => {
    if (evt.Direction !== 'InDirection' || !isTodayInDenver(evt.Dateonly)) return;
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    if (evicted.has(key)) return;
    const prev = liveMap.get(key);
    const now  = DateTime.fromISO(evt.LocaleMessageTime).toMillis();
    if (!prev || now > DateTime.fromISO(prev.LocaleMessageTime).toMillis()) {
      liveMap.set(key, evt);
    }
  });
  let finalList = Array.from(liveMap.values());

  // ← Fallback: dedupe fresh InDirection if no liveList found
  if (finalList.length === 0) {
    const freshIns = freshEvents.filter(e =>
      e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
    );
    if (freshIns.length > 0) {
      const fallbackMap = new Map();
      freshIns.forEach(evt => {
        const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
        const prev = fallbackMap.get(key);
        const now  = DateTime.fromISO(evt.LocaleMessageTime).toMillis();
        if (!prev || now > DateTime.fromISO(prev.LocaleMessageTime).toMillis()) {
          fallbackMap.set(key, evt);
        }
      });
      finalList = Array.from(fallbackMap.values());
    }
  }

  // ─── 2) Live occupancy counts & floor breakdown ────────────────
  let liveEmployees   = 0;
  let liveContractors = 0;
  const floorMap = {};
  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (
      e.PersonnelType === 'Employee' ||
      e.PersonnelType === 'Terminated Personnel'
    ) {
      liveEmployees++;
    } else {
      liveContractors++;
    }
  });
  const floorBreakdown = Object.entries(floorMap).map(
    ([floor, occ]) => ({ floor, total: occ.length, occupants: occ })
  );

  // ─── 3) Live personnel breakdown ───────────────────────────────
  const personnelBreakdown = Object.entries(
    finalList.reduce((m, e) => {
      m.set(e.PersonnelType, (m.get(e.PersonnelType) || 0) + 1);
      return m;
    }, new Map())
  ).map(([personnelType, count]) => ({ personnelType, count }));

  // ─── 4) Swipe stats (freshEvents only) ─────────────────────────
  const totalInSwipes  = freshEvents.filter(e =>
    e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
  ).length;
  const totalOutSwipes = freshEvents.filter(e =>
    e.Direction === 'OutDirection' && isTodayInDenver(e.Dateonly)
  ).length;

  // ─── 5) Floor In/Out summary (strict doors only) ───────────────
  const validEvents = allEvents
    .filter(e => isTodayInDenver(e.Dateonly))
    .filter(evt => {
      const key = normalizeKey(evt.Door.trim(), evt.Direction.trim());
      return normalizedMonitoredKeys.has(key);
    });

  const dedupIO = new Map();
  validEvents.forEach(evt => {
    const fl     = mapDoorToFloor(evt.Door, evt.Direction);
    const mapKey = `${evt.PersonGUID}___${fl}___${evt.Direction}`;
    const prev   = dedupIO.get(mapKey);
    const now    = DateTime.fromFormat(evt.Swipe_Time, 'HH:mm:ss');
    if (!prev || now > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      dedupIO.set(mapKey, evt);
    }
  });

  const floorInOutSummary = Object.values(
    Object.entries(
      Array.from(dedupIO.values()).reduce((acc, evt) => {
        const fl = mapDoorToFloor(evt.Door, evt.Direction);
        if (fl === 'Out of office') return acc;
        acc[fl] = acc[fl] || {
          inSwipes:  0,
          outSwipes: 0,
          inSet:     new Set(),
          outSet:    new Set()
        };
        if (evt.Direction === 'InDirection') {
          acc[fl].inSwipes++;
          acc[fl].inSet.add(evt.PersonGUID);
        } else {
          acc[fl].outSwipes++;
          acc[fl].outSet.add(evt.PersonGUID);
        }
        return acc;
      }, {})
    ).map(([floor, stats]) => ({
      floor,
      inSwipes:      stats.inSwipes,
      outSwipes:     stats.outSwipes,
      inOnlyCount:   [...stats.inSet].filter(id => !stats.outSet.has(id)).length,
      inOnlyPersons: [...stats.inSet].filter(id => !stats.outSet.has(id))
    }))
  );

  // ─── 6) Visitors today (first-swipe only) ──────────────────────
  const totalVisitedToday = computeTotalVisitedToday(allEvents);
  const seenMap = new Map();
  allEvents.forEach(evt => {
    if (
      evt.Direction !== 'InDirection' ||
      !isTodayInDenver(evt.Dateonly)
    ) return;
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    if (!seenMap.has(key)) seenMap.set(key, evt.PersonnelType);
  });
  let visitedEmployees   = 0;
  let visitedContractors = 0;
  seenMap.forEach(type => {
    if (type === 'Employee' || type === 'Terminated Personnel') {
      visitedEmployees++;
    } else {
      visitedContractors++;
    }
  });

  // ─── 7) Return full payload ─────────────────────────────────────
  return {
    asOf:               new Date().toISOString(),

    // live occupancy
    currentCount:       finalList.length,
    floorBreakdown,
    personnelSummary:   { employees: liveEmployees, contractors: liveContractors },
    personnelBreakdown,

    // visitors today
    totalVisitedToday,
    visitedToday:       {
      employees:   visitedEmployees,
      contractors: visitedContractors,
      total:       seenMap.size
    },

    // swipe stats & in/out summary
    swipeStats:         { totalInSwipes, totalOutSwipes },
    floorInOutSummary
  };
}

exports.getDenverLiveOccupancy = async (req, res) => {
  await denver.pool.connect();
  res.writeHead(200, {
    'Content-Type':  'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection':    'keep-alive'
  });
  res.write('\n');

  let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const events = [];

  const push = async () => {
    const fresh = await fetchNewEvents(lastSeen);
    if (fresh.length) {
      lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
      events.push(...fresh);
    }
    const payload = buildOccupancyForToday(events, fresh);
    res.write(`data: ${JSON.stringify(payload)}\n\n`);
  };

  await push();
  const timer = setInterval(push, 1000);
  req.on('close', () => clearInterval(timer));
};





As per above file we get total visited today but we don’t get count and details of live occupancy let see  also people are not swipe their badge on out Direction then why live count is not displayed 


Read this file carefully and give me update js file 

// controllers/denverLiveOccupancyController.js

const { DateTime }       = require('luxon');
const { denver }         = require('../config/siteConfig');
const doorFloorMap       = require('../data/denverDoorFloorMap');
const { monitoredDoors } = require('../data/strictDoorList');
const sql                = require('mssql');
const normalizeKey       = require('../data/normalizeKey');

const warnedKeys = new Set();
const normalizedMonitoredKeys = new Set(
  Object.entries(monitoredDoors).map(
    ([door, dir]) => normalizeKey(door, dir)
  )
);

function mapDoorToFloor(rawDoor, rawDir) {
  const key = normalizeKey(rawDoor, rawDir);
  if (doorFloorMap[key]) return doorFloorMap[key];
  const m = rawDoor.match(/HQ\.\s*(\d{1,2})\b/);
  if (m) return `Floor ${m[1]}`;
  if (!warnedKeys.has(key)) {
    console.warn(`⛔ Unmapped door-floor key: "${key}"`);
    warnedKeys.add(key);
  }
  return 'Unknown Floor';
}

function isTodayInDenver(dateOnly) {
  const swipeDate = DateTime.fromISO(dateOnly, { zone: 'America/Denver' })
    .toFormat('yyyy-LL-dd');
  const today     = DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
  return swipeDate === today;
}

async function fetchNewEvents(since) {
  const pool = await denver.pool.connect();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);
  const { recordset } = await req.query(`
    /* … your same SQL … */
  `);
  return recordset;
}

function computeTotalVisitedToday(allEvents) {
  const seen = new Set();
  allEvents.forEach(evt => {
    if (evt.Direction === 'InDirection' && isTodayInDenver(evt.Dateonly)) {
      const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
      seen.add(key);
    }
  });
  return seen.size;
}

function buildOccupancyForToday(allEvents, freshEvents) {
  // ─── A) Evict truly Out-of-office ────────────────────────────────
  const evicted     = new Set();
  const lastByPerson = new Map();
  allEvents.forEach(evt => {
    if (!isTodayInDenver(evt.Dateonly)) return;
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    const prev = lastByPerson.get(key);
    if (!prev || evt.LocaleMessageTime > prev.LocaleMessageTime) {
      lastByPerson.set(key, evt);
    }
  });
  lastByPerson.forEach(evt => {
    if (
      evt.Direction === 'OutDirection' &&
      mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office'
    ) {
      evicted.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    }
  });
  const activeEvents = allEvents.filter(evt => {
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    return !evicted.has(key);
  });

  // ─── 1) Live occupancy dedupe by last InDirection ───────────────
  const latestByPerson = new Map();
  activeEvents.forEach(evt => {
    if (evt.Direction !== 'InDirection' || !isTodayInDenver(evt.Dateonly)) return;
    const key = evt.PersonGUID;
    const prev = latestByPerson.get(key);
    const now  = DateTime.fromFormat(evt.Swipe_Time, 'HH:mm:ss');
    if (!prev || now > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      latestByPerson.set(key, evt);
    }
  });
  let finalList = Array.from(latestByPerson.values());

  // ← Fallback: if after eviction/dedupe there are NO live occupants,
  // but we did just fetch some fresh InDirection swipes, use those:
  if (finalList.length === 0) {
    const freshIns = freshEvents.filter(e =>
      e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
    );
    if (freshIns.length > 0) {
      finalList = freshIns;
    }
  }

  // ─── 2) Live occupancy counts & floor breakdown ────────────────
  let liveEmployees   = 0;
  let liveContractors = 0;
  const floorMap = {};
  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') {
      liveEmployees++;
    } else {
      liveContractors++;
    }
  });
  const floorBreakdown = Object.entries(floorMap).map(([floor, occ]) => ({
    floor, total: occ.length, occupants: occ
  }));

  // ─── 3) Live personnel breakdown ───────────────────────────────
  const personnelBreakdown = Object.entries(
    finalList.reduce((m, e) => {
      m.set(e.PersonnelType, (m.get(e.PersonnelType) || 0) + 1);
      return m;
    }, new Map())
  ).map(([personnelType, count]) => ({ personnelType, count }));

  // ─── 4) Swipe stats (freshEvents only) ─────────────────────────
  const totalInSwipes  = freshEvents.filter(e =>
    e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
  ).length;
  const totalOutSwipes = freshEvents.filter(e =>
    e.Direction === 'OutDirection' && isTodayInDenver(e.Dateonly)
  ).length;

  // ─── 5) Floor In/Out summary (strict doors only) ───────────────
  const validEvents = allEvents
    .filter(e => isTodayInDenver(e.Dateonly))
    .filter(evt => {
      const key = normalizeKey(evt.Door.trim(), evt.Direction.trim());
      return normalizedMonitoredKeys.has(key);
    });

  const dedupedIO = new Map();
  validEvents.forEach(evt => {
    const fl     = mapDoorToFloor(evt.Door, evt.Direction);
    const mapKey = `${evt.PersonGUID}___${fl}___${evt.Direction}`;
    const prev   = dedupedIO.get(mapKey);
    const now    = DateTime.fromFormat(evt.Swipe_Time, 'HH:mm:ss');
    if (!prev || now > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      dedupedIO.set(mapKey, evt);
    }
  });

  const floorIO = {};
  Array.from(dedupedIO.values()).forEach(evt => {
    const fl = mapDoorToFloor(evt.Door, evt.Direction);
    if (fl === 'Out of office') return;
    floorIO[fl] = floorIO[fl] || {
      inSwipes:  0,
      outSwipes: 0,
      inSet:     new Set(),
      outSet:    new Set()
    };
    if (evt.Direction === 'InDirection') {
      floorIO[fl].inSwipes++;
      floorIO[fl].inSet.add(evt.PersonGUID);
    } else {
      floorIO[fl].outSwipes++;
      floorIO[fl].outSet.add(evt.PersonGUID);
    }
  });
  const floorInOutSummary = Object.entries(floorIO).map(([floor, stats]) => {
    const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
    return {
      floor,
      inSwipes:      stats.inSwipes,
      outSwipes:     stats.outSwipes,
      inOnlyCount:   inOnly.length,
      inOnlyPersons: inOnly
    };
  });

  // ─── 6) Visitors today (first-swipe only) ──────────────────────
  const totalVisitedToday = computeTotalVisitedToday(allEvents);
  const seenMap = new Map();
  allEvents.forEach(evt => {
    if (evt.Direction !== 'InDirection' || !isTodayInDenver(evt.Dateonly)) return;
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    if (!seenMap.has(key)) seenMap.set(key, evt.PersonnelType);
  });
  let visitedEmployees   = 0;
  let visitedContractors = 0;
  seenMap.forEach(type => {
    if (type === 'Employee' || type === 'Terminated Personnel') {
      visitedEmployees++;
    } else {
      visitedContractors++;
    }
  });

  // ─── 7) Build and return payload ───────────────────────────────
  return {
    asOf:               new Date().toISOString(),

    // live occupancy
    currentCount:       finalList.length,
    floorBreakdown,
    personnelSummary:   { employees: liveEmployees, contractors: liveContractors },
    personnelBreakdown,

    // visitors today
    totalVisitedToday,
    visitedToday:       {
      employees:   visitedEmployees,
      contractors: visitedContractors,
      total:       seenMap.size
    },

    // swipe stats + strict in/out summary
    swipeStats:         { totalInSwipes, totalOutSwipes },
    floorInOutSummary
  };
}

exports.getDenverLiveOccupancy = async (req, res) => {
  await denver.pool.connect();
  res.writeHead(200, {
    'Content-Type':  'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection':    'keep-alive'
  });
  res.write('\n');

  let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const events = [];

  const push = async () => {
    const fresh = await fetchNewEvents(lastSeen);
    if (fresh.length) {
      lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
      events.push(...fresh);
    }
    const payload = buildOccupancyForToday(events, fresh);
    res.write(`data: ${JSON.stringify(payload)}\n\n`);
  };

  await push();
  const timer = setInterval(push, 1000);
  req.on('close', () => clearInterval(timer));
};






