// controllers/denverLiveOccupancyController.js

// … earlier imports and helper functions …

function buildOccupancyForToday(allEvents) {
  // --- TRACK swipe counts & per-person direction history ---
  const swipeHistory   = new Map();
  const firstEvent     = new Map();
  let totalInSwipes    = 0;
  let totalOutSwipes   = 0;

  allEvents.forEach(evt => {
    if (!isTodayInDenver(evt.Dateonly)) return;
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber || evt.ObjectName1;

    if (!swipeHistory.has(key)) {
      swipeHistory.set(key, new Set());
      firstEvent.set(key, evt);
    }
    swipeHistory.get(key).add(evt.Direction);

    if (evt.Direction === 'InDirection') totalInSwipes++;
    if (evt.Direction === 'OutDirection') totalOutSwipes++;
  });

  // --- DEDUPE & current occupancy ---
  const todayIn = allEvents.filter(e =>
    e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
  );

  const uniquePeople = new Map();
  const current = {};

  allEvents.forEach(evt => {
    if (!isTodayInDenver(evt.Dateonly)) return;
    const {
      EmployeeID, PersonGUID,
      ObjectName1, PersonnelType,
      CardNumber, Dateonly,
      Swipe_Time, Direction, Door
    } = evt;

    const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
    const zone     = mapDoorToFloor(Door, Direction);

    // Eviction logic
    if (Direction === 'OutDirection' && zone === 'Out of office') {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
      return;
    }

    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = { Dateonly, Swipe_Time, EmployeeID, ObjectName1, CardNumber, PersonnelType, zone };
    } else {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
    }
  });

  // Latest swipe per person
  const latestByPerson = new Map();
  todayIn.forEach(e => {
    const prev = latestByPerson.get(e.PersonGUID);
    const tcur = DateTime.fromFormat(e.Swipe_Time, 'HH:mm:ss');
    if (!prev || tcur > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      latestByPerson.set(e.PersonGUID, e);
    }
  });
  const finalList = Array.from(latestByPerson.values());

  // --- TALLY & GROUP BY FLOOR ---
  let employees   = 0;
  let contractors = 0;
  const floorMap  = {};

  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);

    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') {
      employees++;
    } else {
      contractors++;
    }
  });

  const floorBreakdown = Object.entries(floorMap).map(([floor, occupants]) => ({
    floor,
    total: occupants.length,
    occupants
  }));

  // --- COMPUTE in-only counts ---
  let inOnlyEmployees   = 0;
  let inOnlyContractors = 0;
  swipeHistory.forEach((dirs, key) => {
    if (dirs.has('InDirection') && !dirs.has('OutDirection')) {
      const evt = firstEvent.get(key);
      if (!evt) return;
      if (evt.PersonnelType === 'Employee' || evt.PersonnelType === 'Terminated Personnel') {
        inOnlyEmployees++;
      } else {
        inOnlyContractors++;
      }
    }
  });

  const swipeStats = {
    totalInSwipes,
    totalOutSwipes,
    inOnlyEmployees,
    inOnlyContractors
  };

  // --- NEW: per-floor In/Out summary with first-swipe-only logic ---
  // 1) Filter to today’s events
  const todayEvents = allEvents.filter(e => isTodayInDenver(e.Dateonly));

  // 2) Prepare de-dupe trackers
  const countedIn  = new Set();
  const countedOut = new Set();
  const floorMapIO = {};

  // 3) Count only first In/Out per person per floor
  todayEvents.forEach(evt => {
    const floorKey  = mapDoorToFloor(evt.Door, evt.Direction);
    const personKey = `${evt.PersonGUID || evt.EmployeeID || evt.CardNumber}___${floorKey}`;

    if (!floorMapIO[floorKey]) {
      floorMapIO[floorKey] = { inSwipes: 0, outSwipes: 0 };
    }

    if (evt.Direction === 'InDirection') {
      if (!countedIn.has(personKey)) {
        floorMapIO[floorKey].inSwipes++;
        countedIn.add(personKey);
      }
    } else if (evt.Direction === 'OutDirection') {
      if (!countedOut.has(personKey)) {
        floorMapIO[floorKey].outSwipes++;
        countedOut.add(personKey);
      }
    }
  });

  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => ({
    floor,
    inSwipes:  stats.inSwipes,
    outSwipes: stats.outSwipes,
    inconsistency: stats.inSwipes - stats.outSwipes
  }));

  // --- FINAL PAYLOAD ---
  return {
    asOf:               new Date().toISOString(),
    currentCount:       finalList.length,
    floorBreakdown,
    personnelSummary:   { employees, contractors },
    personnelBreakdown: finalList.reduce((acc, e) => {
      acc[e.PersonnelType] = (acc[e.PersonnelType] || 0) + 1;
      return acc;
    }, {}),
    totalVisitedToday:  finalList.length,
    visitedToday:       { employees, contractors, total: finalList.length },
    swipeStats,
    floorInOutSummary
  };
}










// controllers/denverLiveOccupancyController.js

 function buildOccupancyForToday(allEvents) {
   // … existing code up to swipeStats …

   // --- NEW: per-floor In/Out summary ---
   const todayEvents = allEvents.filter(e => isTodayInDenver(e.Dateonly));
-  const floorMapIO = {};
-
-  todayEvents.forEach(evt => {
-    const floor = mapDoorToFloor(evt.Door, evt.Direction);
-    const key   = evt.EmployeeID;
-
-    if (!floorMapIO[floor]) {
-      floorMapIO[floor] = {
-        inSwipes:  0,
-        outSwipes: 0,
-        inSet:  new Set(),
-        outSet: new Set()
-      };
-    }
-
-    if (evt.Direction === 'InDirection') {
-      floorMapIO[floor].inSwipes++;
-      floorMapIO[floor].inSet.add(key);
-    } else if (evt.Direction === 'OutDirection') {
-      floorMapIO[floor].outSwipes++;
-      floorMapIO[floor].outSet.add(key);
-    }
-  });
+  const floorMapIO = {};
+  // Track per-person first In/Out per floor
+  const countedIn  = new Set();
+  const countedOut = new Set();
+
+  todayEvents.forEach(evt => {
+    const floor = mapDoorToFloor(evt.Door, evt.Direction);
+    const personKey = `${evt.PersonGUID || evt.EmployeeID || evt.CardNumber}___${floor}`;
+
+    if (!floorMapIO[floor]) {
+      floorMapIO[floor] = { inSwipes: 0, outSwipes: 0 };
+    }
+
+    if (evt.Direction === 'InDirection') {
+      // only count the first In swipe for this person on this floor today
+      if (!countedIn.has(personKey)) {
+        floorMapIO[floor].inSwipes++;
+        countedIn.add(personKey);
+      }
+    } else if (evt.Direction === 'OutDirection') {
+      // only count the first Out swipe for this person on this floor today
+      if (!countedOut.has(personKey)) {
+        floorMapIO[floor].outSwipes++;
+        countedOut.add(personKey);
+      }
+    }
+  });
 
-  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => {
-    const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
-    return {
-      floor,
-      inSwipes:      stats.inSwipes,
-      outSwipes:     stats.outSwipes,
-      inOnlyCount:   inOnly.length,
-      inOnlyPersons: inOnly
-    };
-  });
+  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, {inSwipes, outSwipes}]) => ({
+    floor,
+    inSwipes,
+    outSwipes,
+    inconsistency: inSwipes - outSwipes
+  }));
 
   // --- FINAL PAYLOAD ---
   return {
     // … other fields …
     floorInOutSummary
   };
 }















Read this file carefully , Read each line by logic,
Issue is there Floor In/Out Swipe Summary Swipe data Count each time means our API continously fetct swipe data ,
in this swipe data display Data come again and again so Entry of Swipe Intime continously increased as per API time it does not chcck time .thats Why we are getting Wrong InDirection Swipe count 
Fix this Issue 

// controllers/denverLiveOccupancyController.js

const { DateTime }      = require('luxon');
const { denver }        = require('../config/siteConfig');
const doorFloorMap      = require('../data/denverDoorFloorMap');
const sql               = require('mssql');

const warnedKeys = new Set();

/** Normalize door+direction key **/
function normalizeKey(rawDoor, rawDir) {
  const d = String(rawDoor || '').trim().replace(/\s+/g, ' ').toUpperCase();
  const dir = /IN/i.test(rawDir) ? 'IN' : 'OUT';
  return `${d}___${dir}`;
}

/** Determine floor label, fallback to “HQ. N.” parsing **/
function mapDoorToFloor(rawDoor, rawDir) {
  const key = normalizeKey(rawDoor, rawDir);
  if (doorFloorMap[key]) {
    return doorFloorMap[key];
  }
  const m = rawDoor.match(/HQ\.\s*(\d{1,2})\b/);
  if (m) {
    return `Floor ${m[1]}`;
  }
  if (!warnedKeys.has(key)) {
    console.warn(`⛔ Unmapped door-floor key: "${key}"`);
    warnedKeys.add(key);
  }
  return 'Unknown Floor';
}

async function fetchNewEvents(since) {
  const pool = await denver.pool.connect();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT 
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR) 
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]' ,'varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]' ,'varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM ACVSUJournal_00010027.dbo.ACVSUJournalLog t1
      LEFT JOIN ACVSCore.Access.Personnel     t2    ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN ACVSCore.Access.PersonnelType t3    ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Name = 'Direction'
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxml t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.ObjectName2 LIKE '%HQ%'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) >= @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return recordset;
}

function isTodayInDenver(dateOnly) {
  const swipeDate = DateTime.fromISO(dateOnly, { zone: 'America/Denver' }).toFormat('yyyy-LL-dd');
  const today     = DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
  return swipeDate === today;
}

function buildOccupancyForToday(allEvents) {
  // --- TRACK swipe counts & per-person direction history ---
  const swipeHistory   = new Map();
  const firstEvent     = new Map();
  let totalInSwipes    = 0;
  let totalOutSwipes   = 0;

  allEvents.forEach(evt => {
    if (!isTodayInDenver(evt.Dateonly)) return;
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber || evt.ObjectName1;

    if (!swipeHistory.has(key)) {
      swipeHistory.set(key, new Set());
      firstEvent.set(key, evt);
    }
    swipeHistory.get(key).add(evt.Direction);

    if (evt.Direction === 'InDirection') totalInSwipes++;
    if (evt.Direction === 'OutDirection') totalOutSwipes++;
  });

  // --- DEDUPE & current occupancy ---
  const todayIn = allEvents.filter(e =>
    e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
  );

  const uniquePeople = new Map();
  const current = {};

  for (const evt of allEvents) {
    const {
      EmployeeID, PersonGUID,
      ObjectName1, PersonnelType,
      CardNumber, Dateonly,
      Swipe_Time, Direction, Door
    } = evt;

    const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
    const zone     = mapDoorToFloor(Door, Direction);

    // OutDirection at “Out of office” evicts
    if (Direction === 'OutDirection' && zone === 'Out of office') {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
      continue;
    }

    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = { Dateonly, Swipe_Time, EmployeeID, ObjectName1, CardNumber, PersonnelType, zone };
    } else {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
    }
  }

  const latestByPerson = new Map();
  todayIn.forEach(e => {
    const prev = latestByPerson.get(e.PersonGUID);
    const tcur = DateTime.fromFormat(e.Swipe_Time, 'HH:mm:ss');
    if (!prev || tcur > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      latestByPerson.set(e.PersonGUID, e);
    }
  });
  const finalList = Array.from(latestByPerson.values());

  // --- TALLY & GROUP BY FLOOR ---
  let employees   = 0;
  let contractors = 0;
  const floorMap  = {};

  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);

    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') {
      employees++;
    } else {
      contractors++;
    }
  });

  const floorBreakdown = Object.entries(floorMap).map(([floor, occupants]) => ({
    floor,
    total:     occupants.length,
    occupants
  }));

  // --- COMPUTE in-only counts ---
  let inOnlyEmployees   = 0;
  let inOnlyContractors = 0;
  swipeHistory.forEach((dirs, key) => {
    if (dirs.has('InDirection') && !dirs.has('OutDirection')) {
      const evt = firstEvent.get(key);
      if (!evt) return;
      if (evt.PersonnelType === 'Employee' || evt.PersonnelType === 'Terminated Personnel') {
        inOnlyEmployees++;
      } else {
        inOnlyContractors++;
      }
    }
  });

  const swipeStats = {
    totalInSwipes,
    totalOutSwipes,
    inOnlyEmployees,
    inOnlyContractors
  };

  // --- NEW: per-floor In/Out summary ---
  const todayEvents = allEvents.filter(e => isTodayInDenver(e.Dateonly));
  const floorMapIO = {};

  todayEvents.forEach(evt => {
    const floor = mapDoorToFloor(evt.Door, evt.Direction);
    const key   = evt.EmployeeID;

    if (!floorMapIO[floor]) {
      floorMapIO[floor] = {
        inSwipes:  0,
        outSwipes: 0,
        inSet:  new Set(),
        outSet: new Set()
      };
    }

    if (evt.Direction === 'InDirection') {
      floorMapIO[floor].inSwipes++;
      floorMapIO[floor].inSet.add(key);
    } else if (evt.Direction === 'OutDirection') {
      floorMapIO[floor].outSwipes++;
      floorMapIO[floor].outSet.add(key);
    }
  });

  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => {
    const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
    return {
      floor,
      inSwipes:      stats.inSwipes,
      outSwipes:     stats.outSwipes,
      inOnlyCount:   inOnly.length,
      inOnlyPersons: inOnly
    };
  });

  // --- FINAL PAYLOAD ---
  return {
    asOf:               new Date().toISOString(),
    currentCount:       finalList.length,
    floorBreakdown,
    personnelSummary:   { employees, contractors },

    // personnelBreakdown: [
    //   { personnelType: 'Employee',   count: employees   },
    //   { personnelType: 'Contractor', count: contractors }
    // ],


personnelBreakdown: (() => {
  const map = new Map();
  finalList.forEach(e => {
    const type = e.PersonnelType || 'Unknown';
    map.set(type, (map.get(type) || 0) + 1);
  });
  return Array.from(map, ([personnelType, count]) => ({ personnelType, count }));
})(),





    totalVisitedToday:  finalList.length,
    visitedToday:       { employees, contractors, total: finalList.length },
    swipeStats,
    floorInOutSummary
  };
}

exports.getDenverLiveOccupancy = async (req, res) => {
  await denver.pool.connect();

  res.writeHead(200, {
    'Content-Type':  'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection':    'keep-alive'
  });
  res.write('\n');

  let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const events = [];

  const push = async () => {
    const fresh = await fetchNewEvents(lastSeen);
    if (fresh.length) {
      lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
      events.push(...fresh);
    }

    const payload = buildOccupancyForToday(events);
    res.write(`data: ${JSON.stringify(payload)}\n\n`);
  };

  await push();
  const timer = setInterval(push, 1000);
  req.on('close', () => clearInterval(timer));
};
