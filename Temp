Read this file carefully issue is there 
We are getting Visited Today count correct Employees Today , Contractors Today count perfectly.

but We are getting unexpected count for Current Total and their breakdown 
cause of out of office count is not removed ,please add condtion and solve this issue give me updated js file carefully



async function buildOccupancy(allEvents) {
  const current      = {};
  const uniquePeople = new Map();

  for (const evt of allEvents) {
    const {
      EmployeeID, PersonGUID,
      ObjectName1, PersonnelType,
      CardNumber, Dateonly,
      Swipe_Time, Direction, Door
    } = evt;

    const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
    const zone     = mapDoorToZone(Door, Direction);

    // 1) True "Out of office" → full eviction
    if (Direction === 'OutDirection' && zone === 'Out of office') {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
      continue;
    }

    // 2) Any other OutDirection (outer areas, reception exits, etc.)
    if (Direction === 'OutDirection' && zone !== 'Out of office') {
      // Update their latest zone/door but keep them counted
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = {
        Dateonly, Swipe_Time,
        EmployeeID, ObjectName1, CardNumber,
        PersonnelType, zone,
        door: Door,
        Direction
      };
      continue;
    }

    // 3) InDirection → normal check-in
    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = {
        Dateonly, Swipe_Time,
        EmployeeID, ObjectName1, CardNumber,
        PersonnelType, zone,
        door: Door,
        Direction
      };
      continue;
    }
  

    //4) Any other case (shouldn’t happen) → safe eviction
    uniquePeople.delete(dedupKey);
    delete current[dedupKey];
  }


 // live headcounts
  let employeeCount   = 0;
  let contractorCount = 0;
  for (const pt of uniquePeople.values()) {
    if (['Employee','Terminated Personnel'].includes(pt)) employeeCount++;
    else contractorCount++;
  }



 // 2) Build zoneDetails from `current`
  const zoneMap = {};
  for (const emp of Object.values(current)) {
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }
  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap)
      // <- filter out real eviction zone here
      .filter(([zone]) => zone !== 'Out of office')
      .map(([zone, emps]) => {
        const byType = emps.reduce((acc, e) => {
          acc[e.PersonnelType] = (acc[e.PersonnelType]||0) + 1;
          return acc;
        }, {});
        return [ zone, { total: emps.length, byPersonnelType: byType, employees: emps } ];
      })
  );

  // 3) Build floorBreakdown from zoneDetails
  const floorMap = {};
  for (const [zone, data] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += data.total;
    for (const [pt, c] of Object.entries(data.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt]||0) + c;
    }
  }


  return {
    asOf:             new Date().toISOString(),
    summary:          Object.entries(zoneDetails).map(([z,d])=>({ zone: z, count: d.total })),
    zoneBreakdown:    Object.entries(zoneDetails).map(([z,d])=>({ zone: z, ...d.byPersonnelType, total: d.total })),
    floorBreakdown:   Object.entries(floorMap).map(([f,d])=>({ floor: f, ...d.byPersonnelType, total: d.total })),
    details:          zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
    personnelBreakdown:[
      { personnelType:'Employee',   count: employeeCount   },
      { personnelType:'Contractor', count: contractorCount }
    ]
  };
}

/** Build “visited today” from the same in‐memory stream */
function buildVisitedToday(allEvents) {
  // IST “today” string
  const today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');

  // only today's InDirection swipes
  const todayIns = allEvents.filter(evt => {
    if (evt.Direction !== 'InDirection' || !evt.LocaleMessageTime) return false;
    const swipeDate = DateTime
      .fromJSDate(evt.LocaleMessageTime, { zone:'Asia/Kolkata' })
      .toFormat('yyyy-LL-dd');
    return swipeDate === today;
  });

  // dedupe by PersonGUID → keep latest
  const dedup = new Map();
  for (const e of todayIns) {
    const prev = dedup.get(e.PersonGUID);
    if (!prev || e.LocaleMessageTime > prev.LocaleMessageTime) {
      dedup.set(e.PersonGUID, e);
    }
  }

  const finalList   = Array.from(dedup.values());
  const employees   = finalList.filter(e =>
    !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management']
      .includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}

/** Server‐Sent‐Events endpoint */
exports.getLiveOccupancy = async (req, res) => {
  try {
    await poolConnect;

    res.writeHead(200, {
      'Content-Type':  'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection':    'keep-alive'
    });
    res.write('\n');

    // pull last 24h on startup
    let lastSeen = new Date(Date.now() - 24*60*60*1000);
    const events = [];

    const push = async () => {
      const fresh = await fetchNewEvents(lastSeen);
      if (fresh.length) {
        lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
        events.push(...fresh);
      }

      // build occupancy + today counts
      const occupancy  = await buildOccupancy(events);
      const todayStats = buildVisitedToday(events);

      occupancy.totalVisitedToday = todayStats.total;
      occupancy.visitedToday      = {
        employees:   todayStats.employees,
        contractors: todayStats.contractors,
        total:       todayStats.total
      };

      res.write(`data: ${JSON.stringify(occupancy)}\n\n`);
    };

    await push();
    const timer = setInterval(push, 1000);
    req.on('close', () => clearInterval(timer));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};
