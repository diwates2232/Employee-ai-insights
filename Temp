This is our Updated js file , Now In out Summary is not Displayed ,
also When some swipe their badge on out direction its count is remove from Floor is fine but its count also remove from toady Total personeel type count aslo 
ex- 

data: {"asOf":"2025-05-29T07:52:50.910Z","currentCount":3,"floorBreakdown":[{"floor":"Floor 06","total":2,"occupants":[
{"LocaleMessageTime":"2025-05-29T01:47:27.000Z","Dateonly":"2025-05-29",
"Swipe_Time":"01:47:27","EmployeeID":"W0022449","PersonGUID":"E0ECF741-9548-463A-9B4E-A3E55D50D4AC",
"ObjectName1":"Angel, Maria","PersonnelType":"Contractor","CardNumber":"613873","AdmitCode":"Admit","Direction":"InDirection","Door":"US.CO.HQ. 06. Fitness Center East_11:01:02"}
,{"LocaleMessageTime":"2025-05-29T00:59:53.000Z","Dateonly":"2025-05-29","Swipe_Time":"00:59:53","EmployeeID":"W0022451",
"PersonGUID":"35327275-1D0C-4BF7-8817-6A76B5F9E29A","ObjectName1":"Alamo, Martin","PersonnelType":"Contractor","CardNumber":"613770","AdmitCode":"Admit","Direction":"InDirection","Door":"US.CO.HQ. 06. North Entry-IN"}]},{"floor":"Floor 11","total":1,"occupants":[{"LocaleMessageTime":"2025-05-29T01:52:14.000Z","Dateonly":"2025-05-29","Swipe_Time":"01:52:14","EmployeeID":"0","PersonGUID":"1962C290-1BA0-41F7-9CB7-DCDA2DB1D1CE","ObjectName1":"DENVER, TEMP_DEN_031 31","PersonnelType":"Temp Badge","CardNumber":"613897","AdmitCode":"Admit","Direction":"InDirection","Door":"US.CO.HQ. 11. IDF Room_11:01:42 Restricted Door"}]}],"personnelSummary":{"employees":0,"contractors":3},"personnelBreakdown":[{"personnelType":"Contractor","count":2},
{"personnelType":"Temp Badge","count":1}],"totalVisitedToday":3,"visitedToday":
{"employees":0,"contractors":3,"total":3},"swipeStats":{"totalInSwipes":1,"totalOutSwipes":0},"floorInOutSummary":[]}


"totalVisitedToday":3,
"Employee"
"Contractor" 

i want match Toatl count brekdown as Employee & Contractor,

Live Occupancy  is match as live count and its breakdown


// controllers/denverLiveOccupancyController.js

const { DateTime }       = require('luxon');
const { denver }         = require('../config/siteConfig');
const doorFloorMap       = require('../data/denverDoorFloorMap');
const { monitoredDoors } = require('../data/strictDoorList');
const sql                = require('mssql');
const normalizeKey = require('../data/normalizeKey');

const warnedKeys = new Set();


/** Determine floor label, fallback to “HQ. N.” parsing **/
function mapDoorToFloor(rawDoor, rawDir) {
  const key = normalizeKey(rawDoor, rawDir);
  if (doorFloorMap[key]) return doorFloorMap[key];
  const m = rawDoor.match(/HQ\.\s*(\d{1,2})\b/);
  if (m) return `Floor ${m[1]}`;
  if (!warnedKeys.has(key)) {
    console.warn(`⛔ Unmapped door-floor key: "${key}"`);
    warnedKeys.add(key);
  }
  return 'Unknown Floor';
}

/** Strip any trailing “_HH:MM:SS” from a door name **/
function stripTimeSuffix(doorRaw) {
  return doorRaw.replace(/_[0-9]{2}:[0-9]{2}:[0-9]{2}$/, '');
}

async function fetchNewEvents(since) {
  const pool = await denver.pool.connect();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]' ,'varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM ACVSUJournal_00010027.dbo.ACVSUJournalLog t1
      LEFT JOIN ACVSCore.Access.Personnel     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeId  = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Name = 'Direction'
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxml t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType   = 'CardAdmitted'
        AND t1.ObjectName2 LIKE '%HQ%'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) >= @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID, PersonGUID, ObjectName1, PersonnelType,
      CardNumber, AdmitCode, Direction, Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return recordset;
}

function isTodayInDenver(dateOnly) {
  const swipeDate = DateTime.fromISO(dateOnly, { zone: 'America/Denver' })
    .toFormat('yyyy-LL-dd');
  const today = DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
  return swipeDate === today;
}

/**
 * Build live occupancy + swipe summaries.
 * @param {Array} allEvents   – cumulative events (for occupancy)
 * @param {Array} freshEvents – just-fetched events (for swipeStats & floorInOut)
 */

function computeVisitedToday(allEvents) {
  const seen = new Set();
  allEvents.forEach(evt => {
    if (evt.Direction === 'InDirection' && isTodayInDenver(evt.Dateonly)) {
      const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
      seen.add(key);
    }
  });
  return seen.size;
}






function buildOccupancyForToday(allEvents, freshEvents) {
  // ─── A) Evict anyone who swiped truly “out of office” ───────────
  const evicted = new Set();
  // scan most recent event per person
  const lastByPerson = new Map();
  allEvents.forEach(evt => {
    if (!isTodayInDenver(evt.Dateonly)) return;
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    const prev = lastByPerson.get(key);
    if (!prev || evt.LocaleMessageTime > prev.LocaleMessageTime) {
      lastByPerson.set(key, evt);
    }
  });
  // any latest event that maps to Out of office evicts
  lastByPerson.forEach(evt => {
    if (evt.Direction === 'OutDirection' && mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office') {
      evicted.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    }
  });
  // filter them out
  const activeEvents = allEvents.filter(evt => {
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    return !evicted.has(key);
  });

  // ─── 1) Occupancy: dedupe by latest InDirection per person ───────
  const todayIn = activeEvents.filter(e =>
    e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
  );
  const latestByPerson = new Map();
  todayIn.forEach(e => {
    const prev = latestByPerson.get(e.PersonGUID);
    const tcur = DateTime.fromFormat(e.Swipe_Time, 'HH:mm:ss');
    if (!prev || tcur > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      latestByPerson.set(e.PersonGUID, e);
    }
  });
  const finalList = Array.from(latestByPerson.values());

  // ─── 2) Floor breakdown & personnel counts ────────────────────────
  let employees = 0, contractors = 0;
  const floorMap = {};
  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') {
      employees++;
    } else {
      contractors++;
    }
  });
  const floorBreakdown = Object.entries(floorMap).map(([floor, occ]) => ({
    floor, total: occ.length, occupants: occ
  }));

  // ─── 3) Personnel breakdown ───────────────────────────────────────
  const personnelBreakdown = Array.from(
    finalList.reduce((m, e) => {
      m.set(e.PersonnelType, (m.get(e.PersonnelType) || 0) + 1);
      return m;
    }, new Map()),
    ([personnelType, count]) => ({ personnelType, count })
  );

  // ─── 4) Swipe stats from freshEvents only ─────────────────────────
  const totalInSwipes  = freshEvents.filter(e =>
    e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
  ).length;
  const totalOutSwipes = freshEvents.filter(e =>
    e.Direction === 'OutDirection' && isTodayInDenver(e.Dateonly)
  ).length;



  const validEvents = allEvents
    .filter(e => isTodayInDenver(e.Dateonly))
    .filter(evt => {
      // normalize to “KEY___DIRECTION”
      const key = normalizeKey(evt.Door.trim(), evt.Direction.trim());
      // only accept if it exactly matches one of your monitoredDoors
      return monitoredDoors[key] === evt.Direction;
    });



  const dedupedMap = new Map();
  validEvents.forEach(evt => {
    // const fl  = mapDoorToFloor(evt.Door, evt.Direction);
    const key = `${evt.EmployeeID}___${fl}___${evt.Direction}`;
    const prev = dedupedMap.get(key);
    const now  = DateTime.fromFormat(evt.Swipe_Time, 'HH:mm:ss');
    if (!prev || now > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      dedupedMap.set(key, evt);
    }
  });



  const floorMapIO = {};
  Array.from(dedupedMap.values()).forEach(evt => {
      if (fl === 'Out of office') return;
    const fl = mapDoorToFloor(evt.Door, evt.Direction);
    floorMapIO[fl] = floorMapIO[fl] || { inSwipes: 0, outSwipes: 0, inSet: new Set(), outSet: new Set() };
    if (evt.Direction === 'InDirection') {
      floorMapIO[fl].inSwipes++;
      floorMapIO[fl].inSet.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    } else {
      floorMapIO[fl].outSwipes++;
      floorMapIO[fl].outSet.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    }
  });

  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => {
    const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
    return {
      floor,
      inSwipes:      stats.inSwipes,
      outSwipes:     stats.outSwipes,
      inOnlyCount:   inOnly.length,
      inOnlyPersons: inOnly
    };
  });

  // ─── 6) Today visited ─────────────────────────────────────────────
  // const visitedToday = { employees, contractors, total: finalList.length };

  // ─── 6) Today visited ─────────────────────────────────────────────
  // total unique people who swiped in today
  const totalVisitedToday = computeVisitedToday(allEvents);
  // current head-count
  const currentCount = finalList.length;



  return {
    asOf:               new Date().toISOString(),
    //currentCount:       finalList.length,
     currentCount,

    floorBreakdown,
    personnelSummary:   { employees, contractors },
    personnelBreakdown,
    totalVisitedToday,              // unique people who visited today
    visitedToday: {                 // breakdown of today's visitors currently inside
      employees,
      contractors,
      total: currentCount
    },

    swipeStats:         { totalInSwipes, totalOutSwipes },
    floorInOutSummary
  };
}

exports.getDenverLiveOccupancy = async (req, res) => {
  await denver.pool.connect();
  res.writeHead(200, {
    'Content-Type':  'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection':    'keep-alive'
  });
  res.write('\n');

  let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const events = [];

  const push = async () => {
    const fresh = await fetchNewEvents(lastSeen);
    if (fresh.length) {
      lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
      events.push(...fresh);
    }
    const payload = buildOccupancyForToday(events, fresh);
    res.write(`data: ${JSON.stringify(payload)}\n\n`);
  };

  await push();
  const timer = setInterval(push, 1000);
  req.on('close', () => clearInterval(timer));
};






















Read below file carefully Now file is working perfectly, issue is 
Floor In/Out Swipe Summary is need to stritckly depend on this C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\data\strictDoorList.js
door list 
and our headcount and Realtime headcount is depend on C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\data\denverDoorFloorMap.js this file door
dont mix logic 

currently issue is When employee swipe their badge and out of office condtion meet then Floor In/Out Swipe Summary make out of office as a Floor , it not fllor.

also  out of office When meet now removes count from HeadCount ut is not correct.
this two are diffrent diffrent condtion make sure thsi is on seprate.

Floor In/Out Swipe Summary in depends on only defined door on C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\data\strictDoorList.js
dont mix logic in out summary and Headcounts

Alos read all file carefully and dont make unneccassary cahnges 





// controllers/denverLiveOccupancyController.js

const { DateTime }       = require('luxon');
const { denver }         = require('../config/siteConfig');
const doorFloorMap       = require('../data/denverDoorFloorMap');
const { monitoredDoors } = require('../data/strictDoorList');
const sql                = require('mssql');
const normalizeKey = require('../data/normalizeKey');

const warnedKeys = new Set();


/** Determine floor label, fallback to “HQ. N.” parsing **/
function mapDoorToFloor(rawDoor, rawDir) {
  const key = normalizeKey(rawDoor, rawDir);
  if (doorFloorMap[key]) return doorFloorMap[key];
  const m = rawDoor.match(/HQ\.\s*(\d{1,2})\b/);
  if (m) return `Floor ${m[1]}`;
  if (!warnedKeys.has(key)) {
    console.warn(`⛔ Unmapped door-floor key: "${key}"`);
    warnedKeys.add(key);
  }
  return 'Unknown Floor';
}

/** Strip any trailing “_HH:MM:SS” from a door name **/
function stripTimeSuffix(doorRaw) {
  return doorRaw.replace(/_[0-9]{2}:[0-9]{2}:[0-9]{2}$/, '');
}

async function fetchNewEvents(since) {
  const pool = await denver.pool.connect();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]' ,'varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM ACVSUJournal_00010027.dbo.ACVSUJournalLog t1
      LEFT JOIN ACVSCore.Access.Personnel     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeId  = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Name = 'Direction'
      LEFT JOIN ACVSUJournal_00010027.dbo.ACVSUJournalLogxml t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM ACVSUJournal_00010027.dbo.ACVSUJournalLogxmlShred
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType   = 'CardAdmitted'
        AND t1.ObjectName2 LIKE '%HQ%'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) >= @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID, PersonGUID, ObjectName1, PersonnelType,
      CardNumber, AdmitCode, Direction, Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return recordset;
}

function isTodayInDenver(dateOnly) {
  const swipeDate = DateTime.fromISO(dateOnly, { zone: 'America/Denver' })
    .toFormat('yyyy-LL-dd');
  const today = DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
  return swipeDate === today;
}

/**
 * Build live occupancy + swipe summaries.
 * @param {Array} allEvents   – cumulative events (for occupancy)
 * @param {Array} freshEvents – just-fetched events (for swipeStats & floorInOut)
 */

function computeVisitedToday(allEvents) {
  const seen = new Set();
  allEvents.forEach(evt => {
    if (evt.Direction === 'InDirection' && isTodayInDenver(evt.Dateonly)) {
      const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
      seen.add(key);
    }
  });
  return seen.size;
}






function buildOccupancyForToday(allEvents, freshEvents) {
  // ─── A) Evict anyone who swiped truly “out of office” ───────────
  const evicted = new Set();
  // scan most recent event per person
  const lastByPerson = new Map();
  allEvents.forEach(evt => {
    if (!isTodayInDenver(evt.Dateonly)) return;
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    const prev = lastByPerson.get(key);
    if (!prev || evt.LocaleMessageTime > prev.LocaleMessageTime) {
      lastByPerson.set(key, evt);
    }
  });
  // any latest event that maps to Out of office evicts
  lastByPerson.forEach(evt => {
    if (evt.Direction === 'OutDirection' && mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office') {
      evicted.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    }
  });
  // filter them out
  const activeEvents = allEvents.filter(evt => {
    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    return !evicted.has(key);
  });

  // ─── 1) Occupancy: dedupe by latest InDirection per person ───────
  const todayIn = activeEvents.filter(e =>
    e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
  );
  const latestByPerson = new Map();
  todayIn.forEach(e => {
    const prev = latestByPerson.get(e.PersonGUID);
    const tcur = DateTime.fromFormat(e.Swipe_Time, 'HH:mm:ss');
    if (!prev || tcur > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      latestByPerson.set(e.PersonGUID, e);
    }
  });
  const finalList = Array.from(latestByPerson.values());

  // ─── 2) Floor breakdown & personnel counts ────────────────────────
  let employees = 0, contractors = 0;
  const floorMap = {};
  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') {
      employees++;
    } else {
      contractors++;
    }
  });
  const floorBreakdown = Object.entries(floorMap).map(([floor, occ]) => ({
    floor, total: occ.length, occupants: occ
  }));

  // ─── 3) Personnel breakdown ───────────────────────────────────────
  const personnelBreakdown = Array.from(
    finalList.reduce((m, e) => {
      m.set(e.PersonnelType, (m.get(e.PersonnelType) || 0) + 1);
      return m;
    }, new Map()),
    ([personnelType, count]) => ({ personnelType, count })
  );

  // ─── 4) Swipe stats from freshEvents only ─────────────────────────
  const totalInSwipes  = freshEvents.filter(e =>
    e.Direction === 'InDirection' && isTodayInDenver(e.Dateonly)
  ).length;
  const totalOutSwipes = freshEvents.filter(e =>
    e.Direction === 'OutDirection' && isTodayInDenver(e.Dateonly)
  ).length;

  // ─── 5) Floor In/Out summary (deduped per person+floor+dir) ───────
  const validEvents = allEvents
    .filter(e => isTodayInDenver(e.Dateonly))
    .filter(evt => {
      const dir     = evt.Direction.trim();
      let doorRaw   = stripTimeSuffix(evt.Door.trim().toUpperCase());
      const isStrict = Object.entries(monitoredDoors).some(
        ([key, reqDir]) => doorRaw === key.toUpperCase() && reqDir === dir
      );
      const isSuffix = (
        (dir === 'InDirection'  && doorRaw.endsWith('-IN'))  ||
        (dir === 'OutDirection' && doorRaw.endsWith('-OUT'))
      );
      return isStrict || isSuffix;
    });

  const dedupedMap = new Map();
  validEvents.forEach(evt => {
    const fl  = mapDoorToFloor(evt.Door, evt.Direction);
    const key = `${evt.EmployeeID}___${fl}___${evt.Direction}`;
    const prev = dedupedMap.get(key);
    const now  = DateTime.fromFormat(evt.Swipe_Time, 'HH:mm:ss');
    if (!prev || now > DateTime.fromFormat(prev.Swipe_Time, 'HH:mm:ss')) {
      dedupedMap.set(key, evt);
    }
  });

  const floorMapIO = {};
  Array.from(dedupedMap.values()).forEach(evt => {
    const fl = mapDoorToFloor(evt.Door, evt.Direction);
    floorMapIO[fl] = floorMapIO[fl] || { inSwipes: 0, outSwipes: 0, inSet: new Set(), outSet: new Set() };
    if (evt.Direction === 'InDirection') {
      floorMapIO[fl].inSwipes++;
      floorMapIO[fl].inSet.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    } else {
      floorMapIO[fl].outSwipes++;
      floorMapIO[fl].outSet.add(evt.PersonGUID || evt.EmployeeID || evt.CardNumber);
    }
  });

  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => {
    const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
    return {
      floor,
      inSwipes:      stats.inSwipes,
      outSwipes:     stats.outSwipes,
      inOnlyCount:   inOnly.length,
      inOnlyPersons: inOnly
    };
  });

  // ─── 6) Today visited ─────────────────────────────────────────────
  // const visitedToday = { employees, contractors, total: finalList.length };

  // ─── 6) Today visited ─────────────────────────────────────────────
  // total unique people who swiped in today
  const totalVisitedToday = computeVisitedToday(allEvents);
  // current head-count
  const currentCount = finalList.length;



  return {
    asOf:               new Date().toISOString(),
    //currentCount:       finalList.length,
     currentCount,

    floorBreakdown,
    personnelSummary:   { employees, contractors },
    personnelBreakdown,
    totalVisitedToday,              // unique people who visited today
    visitedToday: {                 // breakdown of today's visitors currently inside
      employees,
      contractors,
      total: currentCount
    },

    swipeStats:         { totalInSwipes, totalOutSwipes },
    floorInOutSummary
  };
}

exports.getDenverLiveOccupancy = async (req, res) => {
  await denver.pool.connect();
  res.writeHead(200, {
    'Content-Type':  'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection':    'keep-alive'
  });
  res.write('\n');

  let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const events = [];

  const push = async () => {
    const fresh = await fetchNewEvents(lastSeen);
    if (fresh.length) {
      lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
      events.push(...fresh);
    }
    const payload = buildOccupancyForToday(events, fresh);
    res.write(`data: ${JSON.stringify(payload)}\n\n`);
  };

  await push();
  const timer = setInterval(push, 1000);
  req.on('close', () => clearInterval(timer));
};




read above file carefully .


C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\data\denverDoorFloorMap.js


const normalizeKey = require('./normalizeKey');
const rawMap = {
  "US.CO.HQ. 12. SOUTH LOBBY DOORS-IN___IN": "Floor 12",
  "US.CO.HQ. 12. SOUTH LOBBY DOORS-IN___OUT": "Out of office",
  "US.CO.HQ. 12. IDF RESTRICTED DOOR___IN": "Floor 12",
  "US.CO.HQ. 12. IDF RESTRICTED DOOR___OUT": "Out of office",
  "US.CO.HQ. 12. STORAGE ROOM_11:01:0A___IN": "Floor 12",
  "US.CO.HQ. 12. STORAGE ROOM_11:01:0A___OUT": "Out of office",
  "US.CO.HQ. 12. NORTH STAIRWELL-IN___IN": "Floor 12",
  "US.CO.HQ. 12. NORTH STAIRWELL-IN___OUT": "Out of office",
  "US.CO.HQ. 12. FREIGHT ELEVATOR LOBBY-IN___IN": "Floor 12",
  "US.CO.HQ. 12. FREIGHT ELEVATOR LOBBY-IN___OUT": "Out of office",
  "US.CO.HQ. 12. MOTHERS ROOM_11:01:CC___IN": "Floor 12",
  "US.CO.HQ. 12. MOTHERS ROOM_11:01:CC___OUT": "Out of office",
"US.CO.HQ. 15. SOUTH STAIRWELL-OUT___IN": "Floor 15",
  "US.CO.HQ. 15. SOUTH STAIRWELL-OUT___OUT": "Out of office"

.
.
.
.
.

}

const doorToFloorMap = {};
for (const [rawKey, floor] of Object.entries(rawMap)) {
  const [doorRaw, dirRaw] = rawKey.split('___');
  const normKey = normalizeKey(doorRaw, dirRaw);
  doorToFloorMap[normKey] = floor;
}

module.exports = doorToFloorMap;






C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\data\strictDoorList.js

module.exports = {
  monitoredDoors: {
    'US.CO.HQ. 12. South Lobby Doors-IN': 'InDirection',
    'US.CO.HQ. 12. North Stairwell-IN': 'InDirection',
    'US.CO.HQ. 12. Freight Elevator Lobby-IN': 'InDirection',
    'US.CO.HQ. 12. South Stairwell-IN': 'InDirection',
    'US.CO.HQ. 11. North Stairwell-IN': 'InDirection',
    'US.CO.HQ. 11. Freight Elevator Lobby-IN':'InDirection',
    'US.CO.HQ. 11. South Stairwell-IN': 'InDirection',
    'US.CO.HQ. 09. South Stairwell-IN': 'InDirection',
    'US.CO.HQ. 09. Freight Elevator Lobby-IN': 'InDirection',
 }
};




C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\data\normalizeKey.js


// data/normalizeKey.js
const HEX_TIME_SUFFIX = /_[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$/i;

function normalizeKey(rawDoor, rawDir) {
  let d = String(rawDoor || '')
    .trim()
    .replace(/\s+/g, ' ')
    .toUpperCase();
  d = d.replace(HEX_TIME_SUFFIX, '');
  const dir = rawDir.trim() === 'InDirection' ? 'IN' : 'OUT';
  return `${d}___${dir}`;
}

module.exports = normalizeKey;

