const { poolConnect, pool, sql } = require('../config/db');
const mapDoorToZone = require('../data/doorZoneMap');
const zoneFloorMap = require('../data/zoneFloorMap');

async function fetchNewEvents(since) {
  const req = pool.request();
  req.input('since', sql.DateTime2, since);
  const result = await req.query(`
    WITH CombinedQuery AS (
      SELECT 
        DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE 
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          SCard.[value]
        ) AS CardNumber,
        t5_admit.value AS AdmitCode,
        t5_dir.value   AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]      t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType]  t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_admit
        ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_dir
        ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, [value]
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE [Name] IN ('Card','CHUID')
      ) AS SCard
        ON t1.XmlGUID = SCard.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return result.recordset;
}

async function buildOccupancy(allEvents) {
  const current = {};
  for (const evt of allEvents) {
    const {
      EmployeeID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      Dateonly,
      Swipe_Time,
      Direction,
      Door
    } = evt;

    let zone = mapDoorToZone(Door, Direction) || 'Unknown Zone';

    if (Direction === 'InDirection') {
      current[EmployeeID] = {
        Dateonly,
        Swipe_Time,
        EmployeeID,
        ObjectName1,
        CardNumber,
        PersonnelType,
        zone
      };
    } else {
      delete current[EmployeeID];
    }
  }

  const zoneMap = {};
  for (const emp of Object.values(current)) {
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }

  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const counts = emps.reduce((acc, { PersonnelType }) => {
        acc[PersonnelType] = (acc[PersonnelType] || 0) + 1;
        return acc;
      }, {});
      return [zone, {
        total: emps.length,
        byPersonnelType: counts,
        employees: emps
      }];
    })
  );

  const floorMap = {};
  for (const [zone, details] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += details.total;
    for (const [ptype, cnt] of Object.entries(details.byPersonnelType)) {
      floorMap[floor].byPersonnelType[ptype] =
        (floorMap[floor].byPersonnelType[ptype] || 0) + cnt;
    }
  }

  const summary = Object.entries(zoneDetails).map(([zone, d]) => ({
    zone,
    count: d.total
  }));

  const zoneBreakdown = Object.entries(zoneDetails).map(
    ([zone, d]) => ({ zone, ...d.byPersonnelType, total: d.total })
  );

  const floorBreakdown = Object.entries(floorMap).map(
    ([floor, d]) => ({ floor, ...d.byPersonnelType, total: d.total })
  );

  return {
    asOf: new Date().toISOString(),
    summary,
    zoneBreakdown,
    floorBreakdown,
    details: zoneMap
  };
}

exports.getLiveOccupancy = async (req, res) => {
  try {
    await poolConnect;

    res.writeHead(200, {
      'Content-Type':      'text/event-stream',
      'Cache-Control':     'no-cache',
      'Connection':        'keep-alive'
    });
    res.write('\n');

    let lastSeen = new Date(Date.now() - 1000 * 60 * 60); // start one hour back (or adjust)

    const allEvents = [];

    const checkForNew = async () => {
      const newEvents = await fetchNewEvents(lastSeen);
      if (newEvents.length > 0) {
        lastSeen = newEvents[newEvents.length - 1].LocaleMessageTime;
        allEvents.push(...newEvents);
        const payload = await buildOccupancy(allEvents);
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
      }
    };

    {
      const recent = await fetchNewEvents(new Date(Date.now() - 1000 * 60 * 60));
      if (recent.length) {
        lastSeen = recent[recent.length - 1].LocaleMessageTime;
        allEvents.push(...recent);
      }
      const initial = await buildOccupancy(allEvents);
      res.write(`data: ${JSON.stringify(initial)}\n\n`);
    }

    const interval = setInterval(checkForNew, 1000);
    req.on('close', () => clearInterval(interval));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};








// controllers/liveOccupancyController.js

const { poolConnect, pool, sql } = require('../config/db');
const mapDoorToZone = require('../data/doorZoneMap');
const zoneFloorMap = require('../data/zoneFloorMap');

async function fetchNewEvents(since) {
  const req = pool.request();
  req.input('since', sql.DateTime2, since);
  const result = await req.query(`
    WITH CombinedQuery AS (
      SELECT 
        DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE 
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          SCard.[value]
        ) AS CardNumber,
        t5_admit.value AS AdmitCode,
        t5_dir.value   AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]      t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType]  t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_admit
        ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred] t5_dir
        ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, [value]
        FROM [ACVSUJournal_00010027].[dbo].[ACVSUJournalLogxmlShred]
        WHERE [Name] IN ('Card','CHUID')
      ) AS SCard
        ON t1.XmlGUID = SCard.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return result.recordset;
}

async function buildOccupancy(allEvents) {
  const current = {};
  for (const evt of allEvents) {
    const {
      EmployeeID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      Dateonly,
      Swipe_Time,
      Direction,
      Door
    } = evt;

    let zone = mapDoorToZone(Door, Direction) || 'Unknown Zone';

    if (Direction === 'InDirection') {
      current[EmployeeID] = {
        Dateonly,
        Swipe_Time,
        EmployeeID,
        ObjectName1,
        CardNumber,
        PersonnelType,
        zone
      };
    } else {
      delete current[EmployeeID];
    }
  }

  const zoneMap = {};
  for (const emp of Object.values(current)) {
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }

  const summary = Object.entries(zoneMap).map(([zone, emps]) => ({
    zone,
    count: emps.length
  }));

  return { asOf: new Date().toISOString(), summary, details: zoneMap };
}

exports.getLiveOccupancy = async (req, res) => {
  try {
    await poolConnect;

    res.writeHead(200, {
      'Content-Type':      'text/event-stream',
      'Cache-Control':     'no-cache',
      'Connection':        'keep-alive'
    });
    res.write('\n');

    let lastSeen = new Date(Date.now() - 1000 * 60 * 60); // start one hour back (or adjust)

    // keep a running list of all in-scope events to compute occupancy
    const allEvents = [];

    const checkForNew = async () => {
      const newEvents = await fetchNewEvents(lastSeen);
      if (newEvents.length > 0) {
        // update our lastSeen to the timestamp of the newest event
        lastSeen = newEvents[newEvents.length - 1].LocaleMessageTime;
        // add them to the master list
        allEvents.push(...newEvents);
        // rebuild occupancy and push
        const payload = await buildOccupancy(allEvents);
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
      }
    };

    // initial emit (empty or existing in last hour)
    {
      const recent = await fetchNewEvents(new Date(Date.now() - 1000*60*60));
      if (recent.length) {
        lastSeen = recent[recent.length-1].LocaleMessageTime;
        allEvents.push(...recent);
      }
      const initial = await buildOccupancy(allEvents);
      res.write(`data: ${JSON.stringify(initial)}\n\n`);
    }

    const interval = setInterval(checkForNew, 1000);

    req.on('close', () => clearInterval(interval));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};

